import { Plugin, TFile, Notice, App, Modal } from 'obsidian';
import { GameLogSettingTab } from './settings';
import { GameCreationModal } from './gameCreationModal';
import { GameLibraryView, GAME_LIBRARY_VIEW_TYPE } from './gameLibraryView';
import { PlaythroughModal } from './playthroughModal';

export interface UserDevice {
    id: string;
    name: string;
    type: DeviceType;
    basePlatform: string;
    
    availableStores: string[];
    enabledStores: string[];
    
    availableSubscriptions: string[];
    enabledSubscriptions: string[];
    
    isDefault: boolean;
    isAutoGenerated: boolean;
}

export type DeviceType = 'computer' | 'handheld' | 'console' | 'hybrid' | 'mobile' | 'custom';

interface GameLogSettings {
    gamesFolder: string;
    rawgApiKey: string;
    autoSaveInterval: number;
    userDevices: UserDevice[];
    showAdvancedDeviceSettings: boolean;
    enabledSubscriptions: Record<string, boolean>;
}

const DEFAULT_SETTINGS: GameLogSettings = {
    gamesFolder: 'Games',
    rawgApiKey: '',
    autoSaveInterval: 30000,
    userDevices: [
        {
            id: 'default-windows-computer',
            name: 'Gaming PC',
            type: 'computer',
            basePlatform: 'Windows',
            availableStores: ['Steam'],
            enabledStores: ['Steam'],
            availableSubscriptions: ['PC Game Pass', 'EA Play', 'Ubisoft+'],
            enabledSubscriptions: [],
            isDefault: true,
            isAutoGenerated: true
        }
    ],
    showAdvancedDeviceSettings: false,
    enabledSubscriptions: {
        'PC Game Pass': false,
        'Xbox Game Pass': false,
        'PlayStation Plus': false,
        'Apple Arcade': false,
        'Nintendo Switch Online': false,
        'EA Play': false,
        'Ubisoft+': false
    }
};

export default class GameLogPlugin extends Plugin {
    settings: GameLogSettings;

    async onload() {
        await this.loadSettings();

        // Simple notice about Meta Bind (no complex checking)
        new Notice(
            'üéÆ Game Log: For full functionality, install "Meta Bind" plugin from Community Plugins. ' +
            'This enables interactive buttons and inputs in playthrough dashboards.',
            6000
        );

        // Add ribbon icon for Game Library
        this.addRibbonIcon('gamepad-2', 'Game Library', () => {
            this.activateGameLibraryView();
        });

        // Add settings tab
        this.addSettingTab(new GameLogSettingTab(this.app, this));

        // Register Game Library view
        this.registerView(
            GAME_LIBRARY_VIEW_TYPE,
            (leaf) => new GameLibraryView(leaf, this)
        );

        // Add commands
        this.addCommand({
            id: 'add-new-game',
            name: 'Add New Game',
            callback: () => {
                this.createNewGame();
            }
        });

        this.addCommand({
            id: 'open-game-library',
            name: 'Open Game Library',
            callback: () => {
                this.activateGameLibraryView();
            }
        });

        this.addCommand({
            id: 'create-playthrough',
            name: 'Create New Playthrough',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && activeFile.path.includes('Game Overview.md')) {
                    if (!checking) {
                        this.createNewPlaythrough(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'start-gaming-session',
            name: 'Start Gaming Session',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.startGamingSession(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'end-gaming-session', 
            name: 'End Gaming Session',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.endGamingSession(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'complete-playthrough',
            name: 'Complete Playthrough',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.completePlaythrough(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        // Monitor frontmatter changes for smart status updates
        this.registerEvent(
            this.app.metadataCache.on('changed', (file: TFile) => {
                this.handleFileChange(file);
            })
        );
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
        
        // Ensure all user devices have required properties with proper defaults
        this.settings.userDevices = this.settings.userDevices.map(device => ({
            ...device,
            availableStores: Array.isArray(device.availableStores) ? device.availableStores : ['Steam'],
            enabledStores: Array.isArray(device.enabledStores) ? device.enabledStores : ['Steam'],
            availableSubscriptions: Array.isArray(device.availableSubscriptions) ? device.availableSubscriptions : [],
            enabledSubscriptions: Array.isArray(device.enabledSubscriptions) ? device.enabledSubscriptions : [],
            isAutoGenerated: device.isAutoGenerated ?? true
        }));
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }
    
    async activateGameLibraryView() {
        const { workspace } = this.app;
        
        let leaf = workspace.getLeavesOfType(GAME_LIBRARY_VIEW_TYPE)[0];
        
        if (!leaf) {
            const newLeaf = workspace.getRightLeaf(false);
            if (newLeaf) {
                await newLeaf.setViewState({
                    type: GAME_LIBRARY_VIEW_TYPE,
                    active: true,
                });
                leaf = newLeaf;
            } else {
                const activeLeaf = workspace.getLeaf(false);
                await activeLeaf.setViewState({
                    type: GAME_LIBRARY_VIEW_TYPE,
                    active: true,
                });
                leaf = activeLeaf;
            }
        }
        
        workspace.revealLeaf(leaf);
    }

    async createNewPlaythrough(gameFile: TFile) {
        try {
            const modal = new PlaythroughModal(this.app, this, gameFile);
            modal.open();
        } catch (error) {
            console.error('Error opening playthrough modal:', error);
            new Notice(`‚ùå Error: ${error.message}`);
        }
    }

    async createNewGame() {
        const modal = new GameCreationModal(this.app, this);
        modal.open();
    }

    async startGamingSession(playthroughFile: TFile) {
        try {
            const cache = this.app.metadataCache.getFileCache(playthroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter) {
                new Notice('‚ùå Invalid playthrough file');
                return;
            }

            if (frontmatter.session_active) {
                new Notice('üéÆ Session already active!');
                return;
            }

            // Update frontmatter to mark session as active
            const now = new Date();
            const sessionStartTime = now.toISOString();
            
            await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
                fm.session_active = true;
                fm.session_start_time = sessionStartTime;
                fm.current_session_notes = fm.current_session_notes || "";
                
                // Smart status update: Auto-activate planned playthroughs
                if (fm.status === "Planned") {
                    fm.status = "Active";
                }
            });

            // Update game overview status
            await this.updateGameOverviewForActiveSession(frontmatter);
            
            // Start auto-save monitoring
            this.startAutoSave(playthroughFile);
            
            new Notice('üéÆ Gaming session started! Auto-save is active.', 3000);
            
        } catch (error) {
            console.error('Error starting session:', error);
            new Notice(`‚ùå Error starting session: ${error.message}`);
        }
    }

    async endGamingSession(playthroughFile: TFile) {
        try {
            const cache = this.app.metadataCache.getFileCache(playthroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter) {
                new Notice('‚ùå Invalid playthrough file');
                return;
            }

            // Smart session detection: Check for unsaved notes even without active session
            if (!frontmatter.session_active) {
                if (frontmatter.current_session_notes && frontmatter.current_session_notes.trim()) {
                    const autoStartSession = await new ConfirmModal(
                        this.app,
                        'No active session found',
                        'You have session notes but haven\'t started a session. Auto-start and immediately end a session to save these notes?'
                    ).waitForUserChoice();
                    
                    if (!autoStartSession) {
                        new Notice('Session end cancelled');
                        return;
                    }
                    
                    try {
                        // Auto-start session first
                        await this.startGamingSession(playthroughFile);
                        
                        // Wait a moment for the session to start
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Refresh the file cache
                        const newCache = this.app.metadataCache.getFileCache(playthroughFile);
                        const newFrontmatter = newCache?.frontmatter;
                        
                        if (!newFrontmatter?.session_active) {
                            new Notice('Failed to start session automatically. Please start session manually first.');
                            return;
                        }
                        
                        // Update our frontmatter reference
                        Object.assign(frontmatter, newFrontmatter);
                        
                    } catch (error) {
                        console.error('Failed to auto-start session:', error);
                        new Notice('Failed to start session automatically. Please start session manually first.');
                        return;
                    }
                    
                } else {
                    new Notice('‚ùå No active session to end');
                    return;
                }
            }

            // Stop auto-save first
            this.stopAutoSave();
            
            // Create session log
            await this.createSessionLog(playthroughFile, frontmatter);
            
            new Notice('‚úÖ Session ended and logged!', 3000);
            
        } catch (error) {
            console.error('Error ending session:', error);
            new Notice(`‚ùå Error ending session: ${error.message}`);
        }
    }

    async completePlaythrough(playthroughFile: TFile) {
    try {
        const cache = this.app.metadataCache.getFileCache(playthroughFile);
        const frontmatter = cache?.frontmatter;
        
        if (!frontmatter?.game_name || !frontmatter?.playthrough_name) {
            new Notice('‚ùå Invalid playthrough file');
            return;
        }

        // Confirm completion with user
        const modal = new ConfirmModal(
            this.app,
            `Complete "${frontmatter.playthrough_name}"?`,
            `This will end any active session, mark the playthrough as finished, and create a complete playthrough summary.`
        );
        
        const confirmed = await modal.waitForUserChoice();
        if (!confirmed) {
            new Notice('Playthrough completion cancelled');
            return;
        }

        // If there's an active session, handle it first
        if (frontmatter.session_active) {
            const endSessionFirst = await new ConfirmModal(
                this.app,
                'Active session detected',
                'Do you want to save the current session before completing the playthrough?'
            ).waitForUserChoice();
            
            if (endSessionFirst) {
                await this.endGamingSession(playthroughFile);
                // Wait for session to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Refresh frontmatter
                const newCache = this.app.metadataCache.getFileCache(playthroughFile);
                if (newCache?.frontmatter) {
                    Object.assign(frontmatter, newCache.frontmatter);
                }
            } else {
                // Stop auto-save and clear session without saving
                this.stopAutoSave();
                await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
                    fm.session_active = false;
                    fm.current_session_notes = "";
                    delete fm.session_start_time;
                    delete fm.last_autosave;
                });
            }
        } else if (frontmatter.current_session_notes && frontmatter.current_session_notes.trim()) {
            // Handle unsaved notes without active session
            const saveNotes = await new ConfirmModal(
                this.app,
                'Unsaved session notes detected',
                'You have session notes that haven\'t been saved. Do you want to create a final session log before completing?'
            ).waitForUserChoice();
            
            if (saveNotes) {
                await this.startGamingSession(playthroughFile);
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.endGamingSession(playthroughFile);
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Refresh frontmatter
                const newCache = this.app.metadataCache.getFileCache(playthroughFile);
                if (newCache?.frontmatter) {
                    Object.assign(frontmatter, newCache.frontmatter);
                }
            }
        }

        // Calculate completion data
        const completionDate = new Date().toISOString().split('T')[0];
        
        // Calculate total playtime from session files
        const sessionData = await this.calculatePlaytimeFromSessions(frontmatter);
        
        // Prompt for final thoughts
        const finalThoughts = await this.promptForFinalThoughts();
        
        // Create completion summary
        const summaryPath = await this.createCompletionSummary(
            frontmatter, 
            completionDate, 
            sessionData, 
            finalThoughts
        );
        
        // Update playthrough frontmatter
        await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
            fm.status = "Completed";
            fm.completion_date = completionDate;
            fm.session_active = false;
            fm.current_session_notes = "";
            delete fm.session_start_time;
            delete fm.last_autosave;
        });
        
        // Update game overview
        await this.updateGameOverviewForCompletion(frontmatter, sessionData.totalMinutes);
        
        new Notice('üéâ Playthrough completed and summary created!', 4000);
        
        // Open the summary file
        const summaryFile = this.app.vault.getAbstractFileByPath(summaryPath);
        if (summaryFile instanceof TFile) {
            await this.app.workspace.getLeaf().openFile(summaryFile);
        }
        
    } catch (error) {
        console.error('Error completing playthrough:', error);
        new Notice(`‚ùå Error completing playthrough: ${error.message}`, 5000);
    }
}

    private async calculatePlaytimeFromSessions(frontmatter: Record<string, unknown>): Promise<{
        totalMinutes: number;
        sessionSummaries: Array<{
            number: number;
            date: string;
            duration: string;
            notes: string;
        }>;
    }> {
        const sessionsFolder = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions`;
        const sessionFiles = this.app.vault.getAbstractFileByPath(sessionsFolder);
        
        let totalMinutes = 0;
        const sessionSummaries: Array<{
            number: number;
            date: string;
            duration: string;
            notes: string;
        }> = [];
        
        // Fixed the typing issue here
        if (sessionFiles && 'children' in sessionFiles && Array.isArray(sessionFiles.children)) {
            for (const sessionFile of sessionFiles.children) {
                if (sessionFile instanceof TFile && 
                    !sessionFile.name.includes('_current_session_') && 
                    sessionFile.extension === 'md') {
                    
                    try {
                        const sessionCache = this.app.metadataCache.getFileCache(sessionFile);
                        const sessionFM = sessionCache?.frontmatter;
                        
                        if (sessionFM && sessionFM.playthrough_id === frontmatter.playthrough_id) {
                            // Parse duration (e.g., "2h 30m" or "45m")
                            const duration = sessionFM.duration || '';
                            const hoursMatch = duration.match(/(\d+)h/);
                            const minutesMatch = duration.match(/(\d+)m/);
                            
                            let sessionMinutes = 0;
                            if (hoursMatch) sessionMinutes += parseInt(hoursMatch[1]) * 60;
                            if (minutesMatch) sessionMinutes += parseInt(minutesMatch[1]);
                            
                            totalMinutes += sessionMinutes;
                            
                            // Get session content for summary
                            const sessionContent = await this.app.vault.read(sessionFile);
                            const notesMatch = sessionContent.match(/## What Happened This Session\n\n([\s\S]*?)\n\n## Notes for Next Session/);
                            const sessionNotes = notesMatch ? notesMatch[1].trim() : 'No notes recorded';
                            
                            sessionSummaries.push({
                                number: sessionFM.session_number || 0,
                                date: sessionFM.session_date || '',
                                duration: duration,
                                notes: sessionNotes
                            });
                        }
                    } catch (error) {
                        console.log(`Could not process session file: ${sessionFile.name}`, error);
                    }
                }
            }
        }
        
        // Sort sessions by number
        sessionSummaries.sort((a, b) => a.number - b.number);
        
        return { totalMinutes, sessionSummaries };
    }

    private async promptForFinalThoughts(): Promise<string> {
            return new Promise((resolve) => {
                const modal = new FinalThoughtsModal(this.app, (thoughts) => {
                    resolve(thoughts);
                });
                modal.open();
            });
        }

        private async createCompletionSummary(
            frontmatter: Record<string, unknown>,
            completionDate: string,
            sessionData: { totalMinutes: number; sessionSummaries: Array<{
                number: number;
                date: string;
                duration: string;
                notes: string;
            }> },
            finalThoughts: string
        ): Promise<string> {
            // Create Reports folder if it doesn't exist
            await this.app.vault.createFolder(`${this.settings.gamesFolder}/${frontmatter.game_name}/Reports`).catch(() => {});
            
            // Calculate total playtime display
            const totalHours = Math.floor(sessionData.totalMinutes / 60);
            const remainingMinutes = sessionData.totalMinutes % 60;
            const totalPlaytime = totalHours > 0 
                ? `${totalHours}h ${remainingMinutes}m` 
                : `${remainingMinutes}m`;
            
            // Create unique filename
            const playthroughId = frontmatter.playthrough_id || 'unknown';
            const summaryFileName = `${frontmatter.game_name} - ${frontmatter.playthrough_name} - ${playthroughId} - COMPLETE SUMMARY.md`;
            const summaryPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Reports/${summaryFileName}`;
            
            const summaryContent = `---
game_name: "${frontmatter.game_name}"
playthrough_name: "${frontmatter.playthrough_name}"
playthrough_id: "${frontmatter.playthrough_id}"
main_objective: "${frontmatter.main_objective || 'None set'}"
status: "Completed"
start_date: "${frontmatter.start_date}"
completion_date: "${completionDate}"
total_sessions: ${frontmatter.total_sessions || 0}
total_playtime: "${totalPlaytime}"
tags:
  - playthrough-summary
  - completed
  - ${typeof frontmatter.game_name === 'string' ? frontmatter.game_name.toLowerCase().replace(/[^a-z0-9]/g, '-') : 'unknown-game'}
---

# ${frontmatter.game_name} - ${frontmatter.playthrough_name} - COMPLETE SUMMARY

## üéØ Playthrough Overview

- **Main Objective**: ${frontmatter.main_objective || 'No specific objective set'}
- **Status**: ‚úÖ **COMPLETED**
- **Start Date**: ${frontmatter.start_date}
- **Completion Date**: ${completionDate}
- **Total Sessions**: ${frontmatter.total_sessions || 0}
- **Total Playtime**: ${totalPlaytime}
- **Playthrough ID**: ${frontmatter.playthrough_id}

---

## üìñ Session History

${sessionData.sessionSummaries.length > 0 ? sessionData.sessionSummaries.map(session => `
### Session ${session.number} - ${session.date}
**Duration**: ${session.duration}

${session.notes}

---`).join('\n') : 'No session records found.'}

## üéâ Final Thoughts

${finalThoughts || 'No final thoughts recorded.'}

## üìä Playthrough Stats

- **Sessions Played**: ${sessionData.sessionSummaries.length}
- **Average Session Length**: ${sessionData.sessionSummaries.length > 0 ? Math.round(sessionData.totalMinutes / sessionData.sessionSummaries.length) + 'm' : 'N/A'}
- **Longest Session**: ${sessionData.sessionSummaries.length > 0 ? sessionData.sessionSummaries.reduce((max, session) => {
    const duration = session.duration;
    const hoursMatch = duration.match(/(\d+)h/);
    const minutesMatch = duration.match(/(\d+)m/);
    let minutes = 0;
    if (hoursMatch) minutes += parseInt(hoursMatch[1]) * 60;
    if (minutesMatch) minutes += parseInt(minutesMatch[1]);
    return minutes > max.minutes ? {duration, minutes} : max;
}, {duration: '0m', minutes: 0}).duration : 'N/A'}

---

*Playthrough completed on ${completionDate}*`;

    await this.app.vault.create(summaryPath, summaryContent);
    return summaryPath;
}

    private async updateGameOverviewForCompletion(frontmatter: Record<string, unknown>, totalMinutes: number) {
        const gameOverviewPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/${frontmatter.game_name} - Game Overview.md`;
        const gameOverviewFile = this.app.vault.getAbstractFileByPath(gameOverviewPath);
        
        if (gameOverviewFile instanceof TFile) {
            await this.app.fileManager.processFrontMatter(gameOverviewFile, (fm) => {
                fm.status = "Completed";
                fm.current_playthrough = "";
                fm.completed_playthroughs = (fm.completed_playthroughs || 0) + 1;
                fm.total_hours = (fm.total_hours || 0) + Math.round(totalMinutes / 60);
            });
        }
    }

    // Helper method to check if a file is a playthrough dashboard
    private isPlaythroughFile(file: TFile): boolean {
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache?.frontmatter;
        return !!(frontmatter?.playthrough_name && frontmatter?.game_name);
    }

    // Helper method to update game overview when session starts
    private async updateGameOverviewForActiveSession(playthroughFrontmatter: Record<string, unknown>) {
        const gameName = playthroughFrontmatter.game_name;
        const playthroughName = playthroughFrontmatter.playthrough_name;
        
        // Find the game overview file
        const gameOverviewPath = `${this.settings.gamesFolder}/${gameName}/${gameName} - Game Overview.md`;
        const gameOverviewFile = this.app.vault.getAbstractFileByPath(gameOverviewPath);
        
        if (gameOverviewFile instanceof TFile) {
            await this.app.fileManager.processFrontMatter(gameOverviewFile, (fm) => {
                fm.status = "Playing";
                fm.current_playthrough = playthroughName;
            });
        }
    }

    // Replace the existing handleFileChange method with this enhanced version
    async handleFileChange(file: TFile) {
        // Check if this is a playthrough file and update game status if needed
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache?.frontmatter;
        
        if (frontmatter?.playthrough_name && frontmatter?.game_name) {
            // This is a playthrough file - update game overview status
            // Add a small delay to ensure frontmatter changes are fully processed
            setTimeout(async () => {
                await this.updateGameStatus(frontmatter.game_name as string);
            }, 100);
        }
    }

    // Replace the existing updateGameStatus method with this comprehensive version
    async updateGameStatus(gameName: string) {
        try {
            const gameOverviewPath = `${this.settings.gamesFolder}/${gameName}/${gameName} - Game Overview.md`;
            const gameOverviewFile = this.app.vault.getAbstractFileByPath(gameOverviewPath);
            
            if (!(gameOverviewFile instanceof TFile)) {
                console.log(`Game overview not found: ${gameOverviewPath}`);
                return;
            }

            // Get all playthroughs for this game
            const playthroughsFolder = `${this.settings.gamesFolder}/${gameName}/Playthroughs`;
            const playthroughsFolderObj = this.app.vault.getAbstractFileByPath(playthroughsFolder);
            
            if (!playthroughsFolderObj || !('children' in playthroughsFolderObj)) {
                console.log(`Playthroughs folder not found: ${playthroughsFolder}`);
                return;
            }

            const playthroughStatuses: string[] = [];
            let activeSessions = 0;
            let currentActivePlaythrough = '';

            // Analyze all playthroughs
            for (const playthroughFile of playthroughsFolderObj.children as TFile[]) {
                if (playthroughFile instanceof TFile && playthroughFile.extension === 'md') {
                    try {
                        const cache = this.app.metadataCache.getFileCache(playthroughFile);
                        const frontmatter = cache?.frontmatter;
                        
                        if (frontmatter?.playthrough_name && frontmatter?.status) {
                            playthroughStatuses.push(frontmatter.status);
                            
                            // Track active sessions
                            if (frontmatter.session_active) {
                                activeSessions++;
                                currentActivePlaythrough = frontmatter.playthrough_name;
                            }
                        }
                    } catch (error) {
                        console.log(`Could not read playthrough: ${playthroughFile.name}`, error);
                    }
                }
            }

            // Determine game status using priority logic
            const gameStatus = this.determineGameStatus(playthroughStatuses, activeSessions);
            
            // Update game overview
            await this.app.fileManager.processFrontMatter(gameOverviewFile, (fm) => {
                fm.status = gameStatus;
                fm.current_playthrough = currentActivePlaythrough;
                fm.total_playthroughs = playthroughStatuses.length;
            });

            console.log(`Updated game "${gameName}" status to: ${gameStatus}`);
            
        } catch (error) {
            console.error(`Error updating game status for ${gameName}:`, error);
        }
    }

    // Replace the existing determineGameStatus method with this updated version
    private determineGameStatus(playthroughStatuses: string[], activeSessions: number): string {
        if (playthroughStatuses.length === 0) {
            return "Not Started";
        }

        // Priority 1: Any active sessions = Playing
        if (activeSessions > 0) {
            return "Playing";
        }

        // Priority 2: Any Active playthroughs = Playing  
        if (playthroughStatuses.includes("Active")) {
            return "Playing";
        }

        // Priority 3: Any Planned playthroughs = Planning
        if (playthroughStatuses.includes("Planned")) {
            return "Planning";
        }

        // Priority 4: All completed = Completed
        if (playthroughStatuses.every(status => status === "Completed")) {
            return "Completed";
        }

        // Priority 5: Any completed with active/planned mix = Playing
        if (playthroughStatuses.includes("Completed") && 
            (playthroughStatuses.includes("Active") || playthroughStatuses.includes("Planned"))) {
            return "Playing";
        }

        // Priority 6: Any On Hold (means you plan to return) = On Hold
        if (playthroughStatuses.includes("On Hold")) {
            return "On Hold";
        }

        // Priority 7: Mix of Completed + Dropped = Completed 
        // (if you completed some and dropped others, focus on the positive)
        if (playthroughStatuses.includes("Completed") && 
            playthroughStatuses.every(status => status === "Completed" || status === "Dropped")) {
            return "Completed";
        }

        // Priority 8: All dropped = Dropped (you're completely done with this game)
        if (playthroughStatuses.every(status => status === "Dropped")) {
            return "Dropped";
        }

        // Priority 9: Mix including dropped = treat as current highest priority status
        // (dropped playthroughs don't affect the game's overall status if others exist)
        const nonDroppedStatuses = playthroughStatuses.filter(status => status !== "Dropped");
        if (nonDroppedStatuses.length > 0) {
            // Recursively determine status ignoring dropped playthroughs
            return this.determineGameStatus(nonDroppedStatuses, activeSessions);
        }

        // Fallback
        return "Planning";
    }

    // Device Management Methods
    private isStoreCompatible(store: string, platform: string): boolean {
        const compatibility: Record<string, string[]> = {
            'Steam': ['Windows', 'Mac', 'Linux', 'SteamOS'],
            'Epic Games Store': ['Windows', 'Mac'],
            'GOG': ['Windows', 'Mac', 'Linux'],
            'Xbox App': ['Windows'],
            'Origin/EA App': ['Windows'],
            'Ubisoft Connect': ['Windows'],
            'Battle.net': ['Windows', 'Mac'],
            'Itch.io': ['Windows', 'Mac', 'Linux'],
            'Humble Store': ['Windows', 'Mac', 'Linux', 'SteamOS'],
            'PlayStation Store': ['PlayStation'],
            'Xbox Store': ['Xbox'],
            'Nintendo eShop': ['Nintendo'],
            'App Store': ['iOS'],
            'Google Play Store': ['Android']
        };
        
        return compatibility[store]?.includes(platform) || false;
    }

    getDefaultPCStores(): string[] {
        const pcDevices = this.settings.userDevices.filter(d => 
            ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(d.basePlatform)
        );
        
        if (pcDevices.length > 0) {
            const windowsDevice = pcDevices.find(d => d.basePlatform === 'Windows');
            const anyPCDevice = pcDevices[0];
            
            const deviceToUse = windowsDevice || anyPCDevice;
            if (deviceToUse && deviceToUse.availableStores.length > 0) {
                return [...deviceToUse.availableStores];
            }
        }
        
        return ['Steam'];
    }

    getActiveDevices(): UserDevice[] {
        return this.settings.userDevices.filter(device => 
            device.enabledStores.length > 0 || device.enabledSubscriptions.length > 0
        );
    }

    getAllDevices(): UserDevice[] {
        return this.settings.userDevices;
    }

    hasPlatform(platform: string): boolean {
        if (platform === 'PC') {
            return this.settings.userDevices.some(d => 
                ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(d.basePlatform)
            );
        }
        
        return this.settings.userDevices.some(d => d.basePlatform === platform);
    }

    async createDefaultDeviceForPlatform(platform: string): Promise<UserDevice | null> {
        const actualPlatform = platform === 'PC' ? 'Windows' : platform;
        
        const existingDevice = this.settings.userDevices.find(d => {
            if (platform === 'PC') {
                return ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(d.basePlatform);
            }
            return d.basePlatform === actualPlatform;
        });
        
        if (existingDevice) return existingDevice;

        const deviceNames: Record<string, string> = {
            'Windows': 'Gaming PC',
            'PlayStation': 'PlayStation 5',
            'Xbox': 'Xbox Series X|S',
            'Nintendo': 'Nintendo Switch'
        };
        
        const deviceTypes: Record<string, DeviceType> = {
            'Windows': 'computer',
            'PlayStation': 'console',
            'Xbox': 'console',
            'Nintendo': 'console'
        };
        
        const deviceName = deviceNames[actualPlatform];
        const deviceType = deviceTypes[actualPlatform];
        
        if (!deviceName || !deviceType) return null;
        
        const newDevice = await this.addDevice(deviceName, deviceType, actualPlatform);
        newDevice.isAutoGenerated = true;
        await this.saveSettings();
        
        return newDevice;
    }

    async removeDevicesForPlatform(platform: string): Promise<boolean> {
        let devicesForPlatform;
        
        if (platform === 'PC') {
            devicesForPlatform = this.settings.userDevices.filter(d => 
                ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(d.basePlatform)
            );
        } else {
            devicesForPlatform = this.settings.userDevices.filter(d => d.basePlatform === platform);
        }
        
        if (devicesForPlatform.length === 0) return false;
        
        if (platform === 'PC') {
            this.settings.userDevices = this.settings.userDevices.filter(d => 
                !['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(d.basePlatform)
            );
        } else {
            this.settings.userDevices = this.settings.userDevices.filter(d => d.basePlatform !== platform);
        }
        
        await this.saveSettings();
        return true;
    }

    async addDevice(deviceName: string, deviceType: DeviceType, basePlatform: string): Promise<UserDevice> {
        const allPossibleStores = [
            'Steam', 'Epic Games Store', 'GOG', 'Xbox App', 
            'Origin/EA App', 'Ubisoft Connect', 'Battle.net', 'Itch.io',
            'Humble Store', 'PlayStation Store', 'Xbox Store', 'Nintendo eShop',
            'App Store', 'Google Play Store'
        ];
        
        const compatibleStores = allPossibleStores.filter(store => 
            this.isStoreCompatible(store, basePlatform)
        );

        const platformSubscriptionDefaults: Record<string, string[]> = {
            'Windows': ['PC Game Pass', 'EA Play', 'Ubisoft+'],
            'Mac': ['Apple Arcade'],
            'Linux': [],
            'SteamOS': [],
            'PlayStation': ['PlayStation Plus', 'EA Play', 'Ubisoft+'],
            'Xbox': ['Xbox Game Pass', 'EA Play'],
            'Nintendo': ['Nintendo Switch Online'],
            'iOS': ['Apple Arcade'],
            'Android': ['Google Play Pass']
        };

        let defaultStores: string[];
        let defaultSubscriptions: string[];
        
        if (compatibleStores.length > 0) {
            if (['Windows', 'Mac', 'Linux', 'SteamOS'].includes(basePlatform)) {
                const existingPCDevice = this.settings.userDevices.find(d => 
                    ['Windows', 'Mac', 'Linux', 'SteamOS'].includes(d.basePlatform)
                );
                
                if (existingPCDevice) {
                    defaultStores = existingPCDevice.availableStores.filter(store => 
                        this.isStoreCompatible(store, basePlatform)
                    );
                } else {
                    const priorityDefaults = ['Steam', 'Epic Games Store', 'GOG'].filter(store => 
                        this.isStoreCompatible(store, basePlatform)
                    );
                    defaultStores = priorityDefaults.length > 0 ? priorityDefaults : compatibleStores.slice(0, 3);
                }
            } else {
                defaultStores = compatibleStores;
            }
            defaultSubscriptions = platformSubscriptionDefaults[basePlatform] || [];
        } else if (basePlatform === 'Custom') {
            defaultStores = ['Other'];
            defaultSubscriptions = [];
        } else {
            defaultStores = [];
            defaultSubscriptions = [];
        }

        const newDevice: UserDevice = {
            id: `device-${Date.now()}`,
            name: deviceName,
            type: deviceType,
            basePlatform: basePlatform,
            availableStores: defaultStores,
            enabledStores: [...defaultStores],
            availableSubscriptions: defaultSubscriptions,
            enabledSubscriptions: defaultSubscriptions.filter(sub => 
                this.settings.enabledSubscriptions[sub] === true
            ),
            isDefault: !this.settings.userDevices.some(d => d.basePlatform === basePlatform && d.isDefault),
            isAutoGenerated: false
        };

        this.settings.userDevices.push(newDevice);
        await this.saveSettings();
        
        return newDevice;
    }

    async removeDevice(deviceId: string): Promise<boolean> {
        const deviceIndex = this.settings.userDevices.findIndex(d => d.id === deviceId);
        
        if (deviceIndex === -1) {
            return false;
        }

        const device = this.settings.userDevices[deviceIndex];
        
        if (this.settings.userDevices.length === 1) {
            new Notice('‚ö†Ô∏è Cannot remove the last device. Add another device first.');
            return false;
        }

        if (device.isDefault) {
            const sameplatformDevices = this.settings.userDevices.filter(d => 
                d.basePlatform === device.basePlatform && d.id !== deviceId
            );
            
            if (sameplatformDevices.length > 0) {
                sameplatformDevices[0].isDefault = true;
            }
        }

        this.settings.userDevices.splice(deviceIndex, 1);
        await this.saveSettings();
        
        new Notice(`üóëÔ∏è Removed device: ${device.name}`);
        return true;
    }

    async updateDeviceSubscriptions() {
        let hasChanges = false;
        
        this.settings.userDevices = this.settings.userDevices.map(device => {
            const originalEnabledSubs = [...device.enabledSubscriptions];
            
            device.enabledSubscriptions = device.availableSubscriptions.filter(sub => 
                this.settings.enabledSubscriptions[sub] === true
            );
            
            if (JSON.stringify(originalEnabledSubs) !== JSON.stringify(device.enabledSubscriptions)) {
                hasChanges = true;
            }
            
            return device;
        });
        
        if (hasChanges) {
            await this.saveSettings();
        }
    }

    getCompatibleStoresForDevice(device: UserDevice): string[] {
        const allPossibleStores = [
            'Steam', 'Epic Games Store', 'GOG', 'Xbox App', 
            'Origin/EA App', 'Ubisoft Connect', 'Battle.net', 'Itch.io',
            'Humble Store', 'PlayStation Store', 'Xbox Store', 'Nintendo eShop',
            'App Store', 'Google Play Store'
        ];
        
        return allPossibleStores.filter(store => 
            this.isStoreCompatible(store, device.basePlatform)
        );
    }

    validateStoreDeviceCombination(store: string, device: UserDevice): boolean {
        return this.isStoreCompatible(store, device.basePlatform);
    }

    // Auto-save system
    private autoSaveInterval: NodeJS.Timeout | null = null;
    private currentPlaythroughFile: TFile | null = null;

    private startAutoSave(playthroughFile: TFile) {
        // Stop any existing auto-save
        this.stopAutoSave();
        
        this.currentPlaythroughFile = playthroughFile;
        
        // Auto-save every 30 seconds
        this.autoSaveInterval = setInterval(async () => {
            await this.performAutoSave();
        }, 30000);
        
        console.log('Auto-save started for:', playthroughFile.path);
    }

    private stopAutoSave() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
        this.currentPlaythroughFile = null;
        console.log('Auto-save stopped');
    }

    private async performAutoSave() {
        if (!this.currentPlaythroughFile) return;
        
        try {
            const cache = this.app.metadataCache.getFileCache(this.currentPlaythroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter || !frontmatter.session_active) {
                this.stopAutoSave();
                return;
            }

            const currentNotes = frontmatter.current_session_notes || '';
            
            if (currentNotes.trim()) {
                // Create auto-save snapshot
                await this.createAutoSaveSnapshot(this.currentPlaythroughFile, frontmatter, currentNotes);
                
                // Update last auto-save timestamp
                await this.app.fileManager.processFrontMatter(this.currentPlaythroughFile, (fm) => {
                    fm.last_autosave = new Date().toISOString();
                });
            }
            
        } catch (error) {
            console.error('Auto-save error:', error);
        }
    }

    private async createAutoSaveSnapshot(playthroughFile: TFile, frontmatter: Record<string, unknown>, notes: string) {
        const snapshotPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions/_current_session_${frontmatter.playthrough_id}.md`;
        
        const snapshotContent = `---
game_name: "${frontmatter.game_name}"
playthrough_name: "${frontmatter.playthrough_name}"
playthrough_id: "${frontmatter.playthrough_id}"
session_date: "${new Date().toISOString().split('T')[0]}"
auto_save_timestamp: "${new Date().toISOString()}"
status: "in_progress"
tags:
  - session-snapshot
---

# Current Session - ${frontmatter.game_name} | ${frontmatter.playthrough_name}

**Auto-saved**: ${new Date().toLocaleString()}

## Session Notes

${notes}

## Current Status
- **Level**: ${frontmatter.current_level || 'Unknown'}
- **Location**: ${frontmatter.current_location || 'Unknown'}

---
*This is an auto-save snapshot. It will be converted to a proper session log when you end your session.*`;

        try {
            const existingFile = this.app.vault.getAbstractFileByPath(snapshotPath);
            
            if (existingFile instanceof TFile) {
                await this.app.vault.modify(existingFile, snapshotContent);
            } else {
                await this.app.vault.create(snapshotPath, snapshotContent);
            }
            
        } catch (error) {
            console.error('Error creating auto-save snapshot:', error);
        }
    }

    private async createSessionLog(playthroughFile: TFile, frontmatter: Record<string, unknown>) {
        // Calculate session info
        const sessionNumber = (typeof frontmatter.total_sessions === 'number' ? frontmatter.total_sessions : 0) + 1;
        const sessionStartTime = typeof frontmatter.session_start_time === 'string' ? frontmatter.session_start_time : new Date().toISOString();
        const sessionEndTime = new Date().toISOString();
        const sessionDate = new Date().toISOString().split('T')[0];
        
        // Calculate duration
        const startTime = new Date(sessionStartTime);
        const endTime = new Date(sessionEndTime);
        const durationMinutes = Math.round((endTime.getTime() - startTime.getTime()) / (1000 * 60));
        const durationHours = Math.floor(durationMinutes / 60);
        const remainingMinutes = durationMinutes % 60;
        const durationText = durationHours > 0 
            ? `${durationHours}h ${remainingMinutes}m` 
            : `${remainingMinutes}m`;

        // Get session notes
        let sessionNotes = typeof frontmatter.current_session_notes === 'string' ? frontmatter.current_session_notes : '';
        
        // Check for auto-save snapshot with more recent notes
        const snapshotPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions/_current_session_${frontmatter.playthrough_id}.md`;
        const snapshotFile = this.app.vault.getAbstractFileByPath(snapshotPath);
        
        if (snapshotFile instanceof TFile) {
            const snapshotContent = await this.app.vault.read(snapshotFile);
            const notesMatch = snapshotContent.match(/## Session Notes\n\n([\s\S]*?)\n\n## Current Status/);
            if (notesMatch && notesMatch[1].trim()) {
                sessionNotes = notesMatch[1].trim();
            }
            // Clean up snapshot file
            await this.app.vault.delete(snapshotFile);
        }

        // Create session log
        const sessionLogContent = `---
game_name: ${frontmatter.game_name || 'Unknown Game'}
playthrough_name: "${frontmatter.playthrough_name}"
playthrough_id: "${frontmatter.playthrough_id}"
session_number: ${sessionNumber}
session_date: "${sessionDate}"
start_time: "${sessionStartTime}"
end_time: "${sessionEndTime}"
duration: "${durationText}"
status: "completed"
tags:
  - session-log
  - ${typeof frontmatter.game_name === 'string' ? frontmatter.game_name.toLowerCase().replace(/[^a-z0-9]/g, '-') : 'unknown-game'}
---

# ${frontmatter.game_name} - ${frontmatter.playthrough_name} - Session ${sessionNumber}

**Date**: ${sessionDate}  
**Duration**: ${durationText}

## What Happened This Session

${sessionNotes || 'No notes recorded for this session.'}

## Notes for Next Session

${frontmatter.notes_for_next_session || 'No notes for next session.'}

---

*Session automatically logged from Playthrough Dashboard*`;

        const sessionLogPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions/Session ${sessionNumber} - ${sessionDate} - ${frontmatter.playthrough_id}.md`;
        await this.app.vault.create(sessionLogPath, sessionLogContent);

        // Update playthrough dashboard
        await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
            fm.total_sessions = sessionNumber;
            fm.last_session = sessionDate;
            fm.session_active = false;
            fm.current_session_notes = ""; // Clear for next session
            fm.notes_from_last_session = fm.notes_for_next_session || "";
            fm.notes_for_next_session = ""; // Clear for new input
            delete fm.session_start_time;
            delete fm.last_autosave;
        });
    }

    onunload() {
        // Cleanup when plugin is disabled
    }
}

     class ConfirmModal extends Modal {
        private title: string;
        private message: string;
        private resolve: (value: boolean) => void = () => {};

        constructor(app: App, title: string, message: string) {
            super(app);
            this.title = title;
            this.message = message;
        }

        waitForUserChoice(): Promise<boolean> {
            return new Promise((resolve) => {
                this.resolve = resolve;
                this.open();
            });
        }

        onOpen() {
            const { contentEl } = this;
            contentEl.empty();

            contentEl.createEl('h2', { text: this.title });
            contentEl.createEl('p', { text: this.message });

            const buttonContainer = contentEl.createDiv();
            buttonContainer.style.cssText = `
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            `;

            const cancelButton = buttonContainer.createEl('button', {
                text: 'Cancel',
                cls: 'mod-cancel'
            });
            cancelButton.onclick = () => {
                this.resolve(false);
                this.close();
            };

            const confirmButton = buttonContainer.createEl('button', {
                text: 'Confirm',
                cls: 'mod-cta'
            });
            confirmButton.onclick = () => {
                this.resolve(true);
                this.close();
            };
        }

        onClose() {
            const { contentEl } = this;
            contentEl.empty();
        }
    }

    class FinalThoughtsModal extends Modal {
        private onSubmit: (thoughts: string) => void;
        private finalThoughts = '';

        constructor(app: App, onSubmit: (thoughts: string) => void) {
            super(app);
            this.onSubmit = onSubmit;
        }

        onOpen() {
            const { contentEl } = this;
            contentEl.empty();

            contentEl.createEl('h2', { text: 'Final Thoughts' });
            contentEl.createEl('p', { 
                text: 'Any final thoughts about this playthrough? (optional)',
                cls: 'setting-item-description'
            });

        const textAreaContainer = contentEl.createDiv();
            textAreaContainer.style.cssText = `
                margin: 15px 0;
            `;

        const textArea = textAreaContainer.createEl('textarea');
            textArea.placeholder = 'What did you think of this playthrough? Any highlights or memorable moments?';
            textArea.value = this.finalThoughts;
            textArea.style.cssText = `
                width: 100%;
                min-height: 120px;
                padding: 10px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 6px;
                background: var(--background-primary);
                color: var(--text-normal);
                font-family: var(--font-interface);
                font-size: 14px;
                resize: vertical;
            `;

            textArea.addEventListener('input', (e) => {
                this.finalThoughts = (e.target as HTMLTextAreaElement).value;
            });

        const buttonContainer = contentEl.createDiv();
            buttonContainer.style.cssText = `
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            `;

        const skipButton = buttonContainer.createEl('button', {
                text: 'Skip',
                cls: 'mod-cancel'
            });
            skipButton.onclick = () => {
                this.onSubmit('');
                this.close();
            };

        const saveButton = buttonContainer.createEl('button', {
                text: 'Save Thoughts',
                cls: 'mod-cta'
            });
            saveButton.onclick = () => {
                this.onSubmit(this.finalThoughts);
                this.close();
            };

        }

        onClose() {
            const { contentEl } = this;
            contentEl.empty();
        }
    }   