import { Plugin, TFile, TFolder, Notice, App, Modal } from 'obsidian';
import { GameLogSettingTab } from './settings';
import { GameCreationModal } from './gameCreationModal';
import { GameLibraryView, GAME_LIBRARY_VIEW_TYPE } from './gameLibraryView';
import { PlaythroughModal } from './playthroughModal';

export interface UserDevice {
    id: string;
    name: string;
    type: DeviceType;
    platforms: string[];                              // Multiple platforms per device
    platformStores: Record<string, string[]>;         // Stores organized by platform  
    platformSubscriptions: Record<string, string[]>;  // Subscriptions organized by platform
    isDefault: boolean;
    isAutoGenerated: boolean;
}

export type DeviceType = 'computer' | 'handheld' | 'console' | 'hybrid' | 'mobile' | 'custom';

interface GameLogSettings {
    gamesFolder: string;
    rawgApiKey: string;
    autoSaveInterval: number;
    userDevices: UserDevice[];
    showAdvancedDeviceSettings: boolean;
    enabledSubscriptions: Record<string, boolean>;
}

const DEFAULT_SETTINGS: GameLogSettings = {
    gamesFolder: 'Games',
    rawgApiKey: '',
    autoSaveInterval: 30000,
    userDevices: [
        {
            id: 'default-gaming-pc',
            name: 'Gaming PC',
            type: 'computer',
            platforms: ['Windows'],
            platformStores: {
                'Windows': ['Steam']
            },
            platformSubscriptions: {
                'Windows': []
            },
            isDefault: true,
            isAutoGenerated: true
        }
    ],
    showAdvancedDeviceSettings: false,
    enabledSubscriptions: {
        'PC Game Pass': false,
        'Xbox Game Pass': false,
        'PlayStation Plus': false,
        'Apple Arcade': false,
        'Nintendo Switch Online': false,
        'EA Play': false,
        'Ubisoft+': false
    }
};

export default class GameLogPlugin extends Plugin {
    settings: GameLogSettings;

    async onload() {
        await this.loadSettings();

        // Simple notice about Meta Bind (no complex checking)
        new Notice(
            '🎮 Game Log: For full functionality, install "Meta Bind" plugin from Community Plugins. ' +
            'This enables interactive buttons and inputs in playthrough dashboards.',
            6000
        );

        // Add ribbon icon for Game Library
        this.addRibbonIcon('gamepad-2', 'Game Library', () => {
            this.activateGameLibraryView();
        });

        // Add settings tab
        this.addSettingTab(new GameLogSettingTab(this.app, this));

        // Register Game Library view
        this.registerView(
            GAME_LIBRARY_VIEW_TYPE,
            (leaf) => new GameLibraryView(leaf, this)
        );

        // Add commands
        this.addCommand({
            id: 'add-new-game',
            name: 'Add New Game',
            callback: () => {
                this.createNewGame();
            }
        });

        this.addCommand({
            id: 'open-game-library',
            name: 'Open Game Library',
            callback: () => {
                this.activateGameLibraryView();
            }
        });

        this.addCommand({
            id: 'create-playthrough',
            name: 'Create New Playthrough',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && activeFile.path.includes('Game Overview.md')) {
                    if (!checking) {
                        this.createNewPlaythrough(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'start-gaming-session',
            name: 'Start Gaming Session',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.startGamingSession(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'end-gaming-session', 
            name: 'End Gaming Session',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.endGamingSession(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'complete-playthrough',
            name: 'Complete Playthrough',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.completePlaythrough(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'share-session-notes',
            name: 'Share Current Session Notes',
            checkCallback: (checking: boolean) => {
                const activeFile = this.app.workspace.getActiveFile();
                if (activeFile && this.isPlaythroughFile(activeFile)) {
                    if (!checking) {
                        this.shareSessionNotes(activeFile);
                    }
                    return true;
                }
                return false;
            }
        });

        this.addCommand({
            id: 'refresh-library-overview',
            name: 'Refresh Library Overview', 
            callback: () => {
                this.createLibraryOverview(true);
            }
        });

        // Monitor frontmatter changes for smart status updates
        this.registerEvent(
            this.app.metadataCache.on('changed', (file: TFile) => {
                this.handleFileChange(file);
            })
        );
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
        
        // Ensure all user devices have required properties with proper defaults
        this.settings.userDevices = this.settings.userDevices.map(device => ({
            ...device,
            platforms: Array.isArray(device.platforms) ? device.platforms : ['Windows'],
            platformStores: device.platformStores || { 'Windows': ['Steam'] },
            platformSubscriptions: device.platformSubscriptions || { 'Windows': [] },
            isAutoGenerated: device.isAutoGenerated ?? true
        }));
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }
    
    async activateGameLibraryView() {
        const { workspace } = this.app;
        
        let leaf = workspace.getLeavesOfType(GAME_LIBRARY_VIEW_TYPE)[0];
        
        if (!leaf) {
            const newLeaf = workspace.getRightLeaf(false);
            if (newLeaf) {
                await newLeaf.setViewState({
                    type: GAME_LIBRARY_VIEW_TYPE,
                    active: true,
                });
                leaf = newLeaf;
            } else {
                const activeLeaf = workspace.getLeaf(false);
                await activeLeaf.setViewState({
                    type: GAME_LIBRARY_VIEW_TYPE,
                    active: true,
                });
                leaf = activeLeaf;
            }
        }
        
        workspace.revealLeaf(leaf);
    }

     private sanitizeForFileSystem(name: string): string {
        return name
            .replace(/[<>:"/\\|?*]/g, '') // Remove invalid filename characters
            .replace(/\s+/g, ' ') // Normalize multiple spaces to single spaces
            .trim(); // Remove leading/trailing whitespace
    }

    async createNewPlaythrough(gameFile: TFile) {
        try {
            const modal = new PlaythroughModal(this.app, this, gameFile);
            modal.open();
        } catch (error) {
            console.error('Error opening playthrough modal:', error);
            new Notice(`❌ Error: ${error.message}`);
        }
    }

    async createNewGame() {
        const modal = new GameCreationModal(this.app, this);
        modal.open();
    }

    async startGamingSession(playthroughFile: TFile) {
        try {
            const cache = this.app.metadataCache.getFileCache(playthroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter) {
                new Notice('❌ Invalid playthrough file');
                return;
            }

            if (frontmatter.session_active) {
                new Notice('🎮 Session already active!');
                return;
            }

            // Update frontmatter to mark session as active
            const now = new Date();
            const sessionStartTime = now.toISOString();
            
            await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
                fm.session_active = true;
                fm.session_start_time = sessionStartTime;
                fm.current_session_notes = fm.current_session_notes || "";
                
                // Smart status update: Auto-activate planned playthroughs
                if (fm.status === "Planned") {
                    fm.status = "Active";
                }
            });

            // Update game overview status
            await this.updateGameOverviewForActiveSession(frontmatter);
            
            // Start auto-save monitoring
            this.startAutoSave(playthroughFile);
            
            new Notice('🎮 Gaming session started! Auto-save is active.', 3000);
            
        } catch (error) {
            console.error('Error starting session:', error);
            new Notice(`❌ Error starting session: ${error.message}`);
        }
    }

    async endGamingSession(playthroughFile: TFile) {
        try {
            const cache = this.app.metadataCache.getFileCache(playthroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter) {
                new Notice('❌ Invalid playthrough file');
                return;
            }

            // Smart session detection: Check for unsaved notes even without active session
            if (!frontmatter.session_active) {
                if (frontmatter.current_session_notes && frontmatter.current_session_notes.trim()) {
                    const autoStartSession = await new ConfirmModal(
                        this.app,
                        'No active session found',
                        'You have session notes but haven\'t started a session. Auto-start and immediately end a session to save these notes?'
                    ).waitForUserChoice();
                    
                    if (!autoStartSession) {
                        new Notice('Session end cancelled');
                        return;
                    }
                    
                    try {
                        // Auto-start session first
                        await this.startGamingSession(playthroughFile);
                        
                        // Wait a moment for the session to start
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Refresh the file cache
                        const newCache = this.app.metadataCache.getFileCache(playthroughFile);
                        const newFrontmatter = newCache?.frontmatter;
                        
                        if (!newFrontmatter?.session_active) {
                            new Notice('Failed to start session automatically. Please start session manually first.');
                            return;
                        }
                        
                        // Update our frontmatter reference
                        Object.assign(frontmatter, newFrontmatter);
                        
                    } catch (error) {
                        console.error('Failed to auto-start session:', error);
                        new Notice('Failed to start session automatically. Please start session manually first.');
                        return;
                    }
                    
                } else {
                    new Notice('❌ No active session to end');
                    return;
                }
            }

            // Stop auto-save first
            this.stopAutoSave();
            
            // Create session log
            await this.createSessionLog(playthroughFile, frontmatter);
            
            new Notice('✅ Session ended and logged!', 3000);
            
        } catch (error) {
            console.error('Error ending session:', error);
            new Notice(`❌ Error ending session: ${error.message}`);
        }
    }

    async shareSessionNotes(playthroughFile: TFile) {
        try {
            const cache = this.app.metadataCache.getFileCache(playthroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter?.game_name || !frontmatter?.playthrough_name) {
                new Notice('❌ Invalid playthrough file');
                return;
            }

            let currentNotes = frontmatter.current_session_notes || '';
            let notesForNext = frontmatter.notes_for_next_session || '';
            let isFromLastSession = false;
            
            // If no current notes and there are previous sessions, try to get last session notes
            if (!currentNotes.trim() && !notesForNext.trim() && frontmatter.total_sessions > 0) {
                const lastSessionData = await this.getLastSessionNotes(frontmatter);
                if (lastSessionData) {
                    currentNotes = lastSessionData.notes;
                    notesForNext = lastSessionData.plans;
                    isFromLastSession = true;
                }
            }
            
            // Final check after trying to get last session data
            if (!currentNotes.trim() && !notesForNext.trim()) {
                new Notice('📝 No session notes to share');
                return;
            }

            // Create share options modal
            new ShareNotesModal(this.app, {
                gameName: frontmatter.game_name,
                playthroughName: frontmatter.playthrough_name,
                currentNotes: currentNotes,
                notesForNext: notesForNext,
                sessionActive: frontmatter.session_active || false,
                totalSessions: frontmatter.total_sessions || 0,
                lastSession: frontmatter.last_session || '',
                isFromLastSession: isFromLastSession
            }).open();
            
        } catch (error) {
            console.error('Error sharing session notes:', error);
            new Notice(`❌ Error sharing notes: ${error.message}`);
        }
    }

    // Helper method to get last session notes
    private async getLastSessionNotes(frontmatter: Record<string, unknown>): Promise<{notes: string, plans: string} | null> {
        try {
            const sessionsFolder = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions`;
            const sessionFiles = this.app.vault.getAbstractFileByPath(sessionsFolder);
            
            if (!(sessionFiles instanceof TFolder)) return null;
            
            // Find the most recent session for this playthrough
            let latestSession: TFile | null = null;
            let latestSessionNumber = 0;
            
            for (const sessionFile of sessionFiles.children) {
                if (sessionFile instanceof TFile && 
                    !sessionFile.name.includes('_current_session_') && 
                    sessionFile.extension === 'md') {
                    
                    const sessionCache = this.app.metadataCache.getFileCache(sessionFile);
                    const sessionFM = sessionCache?.frontmatter;
                    
                    if (sessionFM && 
                        sessionFM.playthrough_id === frontmatter.playthrough_id &&
                        sessionFM.session_number > latestSessionNumber) {
                        latestSession = sessionFile;
                        latestSessionNumber = sessionFM.session_number;
                    }
                }
            }
            
            if (!latestSession) return null;
            
            // Read the session content
            const sessionContent = await this.app.vault.read(latestSession);
            const notesMatch = sessionContent.match(/## What Happened This Session\n\n([\s\S]*?)\n\n## Notes for Next Session/);
            const plansMatch = sessionContent.match(/## Notes for Next Session\n\n([\s\S]*?)(\n\n---|\n*$)/);
            
            return {
                notes: notesMatch ? notesMatch[1].trim() : '',
                plans: plansMatch ? plansMatch[1].trim() : ''
            };
            
        } catch (error) {
            console.error('Error getting last session notes:', error);
            return null;
        }
    }

    async completePlaythrough(playthroughFile: TFile) {
    try {
        const cache = this.app.metadataCache.getFileCache(playthroughFile);
        const frontmatter = cache?.frontmatter;
        
        if (!frontmatter?.game_name || !frontmatter?.playthrough_name) {
            new Notice('❌ Invalid playthrough file');
            return;
        }

        // Confirm completion with user
        const modal = new ConfirmModal(
            this.app,
            `Complete "${frontmatter.playthrough_name}"?`,
            `This will end any active session, mark the playthrough as finished, and create a complete playthrough summary.`
        );
        
        const confirmed = await modal.waitForUserChoice();
        if (!confirmed) {
            new Notice('Playthrough completion cancelled');
            return;
        }

        // If there's an active session, handle it first
        if (frontmatter.session_active) {
            const endSessionFirst = await new ConfirmModal(
                this.app,
                'Active session detected',
                'Do you want to save the current session before completing the playthrough?'
            ).waitForUserChoice();
            
            if (endSessionFirst) {
                await this.endGamingSession(playthroughFile);
                // Wait for session to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Refresh frontmatter
                const newCache = this.app.metadataCache.getFileCache(playthroughFile);
                if (newCache?.frontmatter) {
                    Object.assign(frontmatter, newCache.frontmatter);
                }
            } else {
                // Stop auto-save and clear session without saving
                this.stopAutoSave();
                await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
                    fm.session_active = false;
                    fm.current_session_notes = "";
                    delete fm.session_start_time;
                    delete fm.last_autosave;
                });
            }
        } else if (frontmatter.current_session_notes && frontmatter.current_session_notes.trim()) {
            // Handle unsaved notes without active session
            const saveNotes = await new ConfirmModal(
                this.app,
                'Unsaved session notes detected',
                'You have session notes that haven\'t been saved. Do you want to create a final session log before completing?'
            ).waitForUserChoice();
            
            if (saveNotes) {
                await this.startGamingSession(playthroughFile);
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.endGamingSession(playthroughFile);
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Refresh frontmatter
                const newCache = this.app.metadataCache.getFileCache(playthroughFile);
                if (newCache?.frontmatter) {
                    Object.assign(frontmatter, newCache.frontmatter);
                }
            }
        }

        // Calculate completion data
        const completionDate = new Date().toISOString().split('T')[0];
        
        // Calculate total playtime from session files
        const sessionData = await this.calculatePlaytimeFromSessions(frontmatter);
        
        // Prompt for final thoughts
        const finalThoughts = await this.promptForFinalThoughts();
        
        // Create completion summary
        const summaryPath = await this.createCompletionSummary(
            frontmatter, 
            completionDate, 
            sessionData, 
            finalThoughts
        );
        
        // Update playthrough frontmatter
        await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
            fm.status = "Completed";
            fm.completion_date = completionDate;
            fm.session_active = false;
            fm.current_session_notes = "";
            delete fm.session_start_time;
            delete fm.last_autosave;
        });
        
        // Update game overview
        await this.updateGameOverviewForCompletion(frontmatter, sessionData.totalMinutes);
        
        new Notice('🎉 Playthrough completed and summary created!', 4000);
        
        // Open the summary file
        const summaryFile = this.app.vault.getAbstractFileByPath(summaryPath);
        if (summaryFile instanceof TFile) {
            await this.app.workspace.getLeaf().openFile(summaryFile);
        }
        
    } catch (error) {
        console.error('Error completing playthrough:', error);
        new Notice(`❌ Error completing playthrough: ${error.message}`, 5000);
    }
}

    private async calculatePlaytimeFromSessions(frontmatter: Record<string, unknown>): Promise<{
        totalMinutes: number;
        sessionSummaries: Array<{
            number: number;
            date: string;
            duration: string;
            notes: string;
        }>;
    }> {
        const sessionsFolder = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions`;
        const sessionFiles = this.app.vault.getAbstractFileByPath(sessionsFolder);
        
        let totalMinutes = 0;
        const sessionSummaries: Array<{
            number: number;
            date: string;
            duration: string;
            notes: string;
        }> = [];
        
        // Fixed the typing issue here
        if (sessionFiles instanceof TFolder) {
            for (const sessionFile of sessionFiles.children) {
                if (sessionFile instanceof TFile && 
                    !sessionFile.name.includes('_current_session_') && 
                    sessionFile.extension === 'md') {
                    
                    try {
                        const sessionCache = this.app.metadataCache.getFileCache(sessionFile);
                        const sessionFM = sessionCache?.frontmatter;
                        
                        if (sessionFM && sessionFM.playthrough_id === frontmatter.playthrough_id) {
                            // Parse duration (e.g., "2h 30m" or "45m")
                            const duration = sessionFM.duration || '';
                            const hoursMatch = duration.match(/(\d+)h/);
                            const minutesMatch = duration.match(/(\d+)m/);
                            
                            let sessionMinutes = 0;
                            if (hoursMatch) sessionMinutes += parseInt(hoursMatch[1]) * 60;
                            if (minutesMatch) sessionMinutes += parseInt(minutesMatch[1]);
                            
                            totalMinutes += sessionMinutes;
                            
                            // Get session content for summary
                            const sessionContent = await this.app.vault.read(sessionFile);
                            const notesMatch = sessionContent.match(/## What Happened This Session\n\n([\s\S]*?)\n\n## Notes for Next Session/);
                            const sessionNotes = notesMatch ? notesMatch[1].trim() : 'No notes recorded';
                            
                            sessionSummaries.push({
                                number: sessionFM.session_number || 0,
                                date: sessionFM.session_date || '',
                                duration: duration,
                                notes: sessionNotes
                            });
                        }
                    } catch (error) {
                        console.log(`Could not process session file: ${sessionFile.name}`, error);
                    }
                }
            }
        }
        
        // Sort sessions by number
        sessionSummaries.sort((a, b) => a.number - b.number);
        
        return { totalMinutes, sessionSummaries };
    }

    private async promptForFinalThoughts(): Promise<string> {
            return new Promise((resolve) => {
                const modal = new FinalThoughtsModal(this.app, (thoughts) => {
                    resolve(thoughts);
                });
                modal.open();
            });
        }

        private async createCompletionSummary(
            frontmatter: Record<string, unknown>,
            completionDate: string,
            sessionData: { totalMinutes: number; sessionSummaries: Array<{
                number: number;
                date: string;
                duration: string;
                notes: string;
            }> },
            finalThoughts: string
        ): Promise<string> {
            // Create Reports folder if it doesn't exist
            await this.app.vault.createFolder(`${this.settings.gamesFolder}/${frontmatter.game_name}/Reports`).catch(() => {});
            
            // Calculate total playtime display
            const totalHours = Math.floor(sessionData.totalMinutes / 60);
            const remainingMinutes = sessionData.totalMinutes % 60;
            const totalPlaytime = totalHours > 0 
                ? `${totalHours}h ${remainingMinutes}m` 
                : `${remainingMinutes}m`;
            
            // Create unique filename
            const playthroughId = frontmatter.playthrough_id || 'unknown';
            const summaryFileName = `${frontmatter.game_name} - ${frontmatter.playthrough_name} - ${playthroughId} - COMPLETE SUMMARY.md`;
            const summaryPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Reports/${summaryFileName}`;
            
            const summaryContent = `---
game_name: "${frontmatter.game_name}"
playthrough_name: "${frontmatter.playthrough_name}"
playthrough_id: "${frontmatter.playthrough_id}"
main_objective: "${frontmatter.main_objective || 'None set'}"
status: "Completed"
start_date: "${frontmatter.start_date}"
completion_date: "${completionDate}"
total_sessions: ${frontmatter.total_sessions || 0}
total_playtime: "${totalPlaytime}"
tags:
  - playthrough-summary
  - completed
  - ${typeof frontmatter.game_name === 'string' ? frontmatter.game_name.toLowerCase().replace(/[^a-z0-9]/g, '-') : 'unknown-game'}
---

# ${frontmatter.game_name} - ${frontmatter.playthrough_name} - COMPLETE SUMMARY

## 🎯 Playthrough Overview

- **Main Objective**: ${frontmatter.main_objective || 'No specific objective set'}
- **Status**: ✅ **COMPLETED**
- **Start Date**: ${frontmatter.start_date}
- **Completion Date**: ${completionDate}
- **Total Sessions**: ${frontmatter.total_sessions || 0}
- **Total Playtime**: ${totalPlaytime}
- **Playthrough ID**: ${frontmatter.playthrough_id}

---

## 📖 Session History

${sessionData.sessionSummaries.length > 0 ? sessionData.sessionSummaries.map(session => `
### Session ${session.number} - ${session.date}
**Duration**: ${session.duration}

${session.notes}

---`).join('\n') : 'No session records found.'}

## 🎉 Final Thoughts

${finalThoughts || 'No final thoughts recorded.'}

## 📊 Playthrough Stats

- **Sessions Played**: ${sessionData.sessionSummaries.length}
- **Average Session Length**: ${sessionData.sessionSummaries.length > 0 ? Math.round(sessionData.totalMinutes / sessionData.sessionSummaries.length) + 'm' : 'N/A'}
- **Longest Session**: ${sessionData.sessionSummaries.length > 0 ? sessionData.sessionSummaries.reduce((max, session) => {
    const duration = session.duration;
    const hoursMatch = duration.match(/(\d+)h/);
    const minutesMatch = duration.match(/(\d+)m/);
    let minutes = 0;
    if (hoursMatch) minutes += parseInt(hoursMatch[1]) * 60;
    if (minutesMatch) minutes += parseInt(minutesMatch[1]);
    return minutes > max.minutes ? {duration, minutes} : max;
}, {duration: '0m', minutes: 0}).duration : 'N/A'}

---

*Playthrough completed on ${completionDate}*`;

    await this.app.vault.create(summaryPath, summaryContent);
    return summaryPath;
}

    private async updateGameOverviewForCompletion(frontmatter: Record<string, unknown>, totalMinutes: number) {
        const gameOverviewPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/${frontmatter.game_name} - Game Overview.md`;
        const gameOverviewFile = this.app.vault.getAbstractFileByPath(gameOverviewPath);
        
        if (gameOverviewFile instanceof TFile) {
            await this.app.fileManager.processFrontMatter(gameOverviewFile, (fm) => {
                fm.status = "Completed";
                fm.current_playthrough = "";
                fm.completed_playthroughs = (fm.completed_playthroughs || 0) + 1;
                fm.total_hours = (fm.total_hours || 0) + Math.round(totalMinutes / 60);
            });
        }
    }

    // Helper method to check if a file is a playthrough dashboard
    private isPlaythroughFile(file: TFile): boolean {
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache?.frontmatter;
        return !!(frontmatter?.playthrough_name && frontmatter?.game_name);
    }

    // Helper method to update game overview when session starts
    private async updateGameOverviewForActiveSession(playthroughFrontmatter: Record<string, unknown>) {
        const gameName = playthroughFrontmatter.game_name;
        const playthroughName = playthroughFrontmatter.playthrough_name;
        
        // Find the game overview file
        const gameOverviewPath = `${this.settings.gamesFolder}/${gameName}/${gameName} - Game Overview.md`;
        const gameOverviewFile = this.app.vault.getAbstractFileByPath(gameOverviewPath);
        
        if (gameOverviewFile instanceof TFile) {
            await this.app.fileManager.processFrontMatter(gameOverviewFile, (fm) => {
                fm.status = "Playing";
                fm.current_playthrough = playthroughName;
            });
        }
    }

    // Replace the existing handleFileChange method with this enhanced version
    async handleFileChange(file: TFile) {
        // Check if this is a playthrough file and update game status if needed
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache?.frontmatter;
        
        if (frontmatter?.playthrough_name && frontmatter?.game_name) {
            // This is a playthrough file - update game overview status
            // Add a small delay to ensure frontmatter changes are fully processed
            setTimeout(async () => {
                await this.updateGameStatus(frontmatter.game_name as string);
            }, 100);
        }
    }

    // Replace the existing updateGameStatus method with this comprehensive version
    async updateGameStatus(gameName: string) {
        try {
            const gameOverviewPath = `${this.settings.gamesFolder}/${gameName}/${gameName} - Game Overview.md`;
            const gameOverviewFile = this.app.vault.getAbstractFileByPath(gameOverviewPath);
            
            if (!(gameOverviewFile instanceof TFile)) {
                console.log(`Game overview not found: ${gameOverviewPath}`);
                return;
            }

            // Get all playthroughs for this game
            const playthroughsFolder = `${this.settings.gamesFolder}/${gameName}/Playthroughs`;
            const playthroughsFolderObj = this.app.vault.getAbstractFileByPath(playthroughsFolder);

            if (!(playthroughsFolderObj instanceof TFolder)) {
                console.log(`Playthroughs folder not found: ${playthroughsFolder}`);
                return;
            }

            const playthroughStatuses: string[] = [];
            let activeSessions = 0;
            let currentActivePlaythrough = '';

            // Analyze all playthroughs
            for (const playthroughFile of playthroughsFolderObj.children) {
                if (playthroughFile instanceof TFile && playthroughFile.extension === 'md') {
                    try {
                        const cache = this.app.metadataCache.getFileCache(playthroughFile);
                        const frontmatter = cache?.frontmatter;
                        
                        if (frontmatter?.playthrough_name && frontmatter?.status) {
                            playthroughStatuses.push(frontmatter.status);
                            
                            // Track active sessions
                            if (frontmatter.session_active) {
                                activeSessions++;
                                currentActivePlaythrough = frontmatter.playthrough_name;
                            }
                        }
                    } catch (error) {
                        console.log(`Could not read playthrough: ${playthroughFile.name}`, error);
                    }
                }
            }

            // Determine game status using priority logic
            const gameStatus = this.determineGameStatus(playthroughStatuses, activeSessions);
            
            // Update game overview
            await this.app.fileManager.processFrontMatter(gameOverviewFile, (fm) => {
                fm.status = gameStatus;
                fm.current_playthrough = currentActivePlaythrough;
                fm.total_playthroughs = playthroughStatuses.length;
            });

            console.log(`Updated game "${gameName}" status to: ${gameStatus}`);
            
        } catch (error) {
            console.error(`Error updating game status for ${gameName}:`, error);
        }
    }

    // Replace the existing determineGameStatus method with this updated version
    private determineGameStatus(playthroughStatuses: string[], activeSessions: number): string {
        if (playthroughStatuses.length === 0) {
            return "Not Started";
        }

        // Priority 1: Any active sessions = Playing
        if (activeSessions > 0) {
            return "Playing";
        }

        // Priority 2: Any Active playthroughs = Playing  
        if (playthroughStatuses.includes("Active")) {
            return "Playing";
        }

        // Priority 3: Any Planned playthroughs = Planning
        if (playthroughStatuses.includes("Planned")) {
            return "Planning";
        }

        // Priority 4: All completed = Completed
        if (playthroughStatuses.every(status => status === "Completed")) {
            return "Completed";
        }

        // Priority 5: Any completed with active/planned mix = Playing
        if (playthroughStatuses.includes("Completed") && 
            (playthroughStatuses.includes("Active") || playthroughStatuses.includes("Planned"))) {
            return "Playing";
        }

        // Priority 6: Any On Hold (means you plan to return) = On Hold
        if (playthroughStatuses.includes("On Hold")) {
            return "On Hold";
        }

        // Priority 7: Mix of Completed + Dropped = Completed 
        // (if you completed some and dropped others, focus on the positive)
        if (playthroughStatuses.includes("Completed") && 
            playthroughStatuses.every(status => status === "Completed" || status === "Dropped")) {
            return "Completed";
        }

        // Priority 8: All dropped = Dropped (you're completely done with this game)
        if (playthroughStatuses.every(status => status === "Dropped")) {
            return "Dropped";
        }

        // Priority 9: Mix including dropped = treat as current highest priority status
        // (dropped playthroughs don't affect the game's overall status if others exist)
        const nonDroppedStatuses = playthroughStatuses.filter(status => status !== "Dropped");
        if (nonDroppedStatuses.length > 0) {
            // Recursively determine status ignoring dropped playthroughs
            return this.determineGameStatus(nonDroppedStatuses, activeSessions);
        }

        // Fallback
        return "Planning";
    }

    async createLibraryOverview(showNotice = false) {
        try {
            const overviewPath = `${this.settings.gamesFolder}/📊 Library Overview.md`;
            
            // Check if overview already exists
            const existingFile = this.app.vault.getAbstractFileByPath(overviewPath);
            if (existingFile && showNotice) {
                // Only ask for confirmation if manually triggered
                const overwrite = await new ConfirmModal(
                    this.app,
                    'Library Overview Exists',
                    'A Library Overview already exists. Do you want to refresh it with current data?'
                ).waitForUserChoice();
                
                if (!overwrite) {
                    // Just open the existing file
                    if (existingFile instanceof TFile) {
                        await this.app.workspace.getLeaf().openFile(existingFile);
                    }
                    return;
                }
                
                // Delete existing file
                await this.app.vault.delete(existingFile);
            } else if (existingFile) {
                // Auto-refresh: just overwrite silently
                await this.app.vault.delete(existingFile);
            }
            
            const overviewContent = this.generateLibraryOverviewContent();
            const overviewFile = await this.app.vault.create(overviewPath, overviewContent);
            
            if (showNotice) {
                new Notice('📊 Library Overview refreshed!');
                // Open the overview when manually triggered
                await this.app.workspace.getLeaf().openFile(overviewFile);
            }
            
        } catch (error) {
            console.error('Error creating library overview:', error);
            if (showNotice) {
                new Notice(`❌ Error creating Library Overview: ${error.message}`);
            }
        }
    }

    private generateLibraryOverviewContent(): string {
        const today = new Date().toISOString().split('T')[0];
        
        return `---
created: "${today}"
type: "library-overview"
tags:
  - game-library
  - overview
  - dashboard
---
\`\`\`meta-bind-button
style: primary
label: 🎮 Open Game Library
id: openLibrary
hidden: true
action:
  type: command
  command: game-log:open-game-library
\`\`\`

\`\`\`meta-bind-button
style: primary
label: ➕ Add New Game
id: addNewGame
hidden: true
action:
  type: command
  command: game-log:add-new-game
\`\`\`

\`\`\`meta-bind-button
style: default
label: 📊 Refresh Overview
id: refreshLibrary
hidden: true
action:
  type: command
  command: game-log:refresh-library-overview
\`\`\`

# 📊 Game Library Overview

*Last updated: ${today}*

## 🎮 Quick Stats

\`\`\`dataview
TABLE WITHOUT ID
  choice(status = "Playing", "🎯 Currently Playing", 
    choice(status = "Planning", "📋 Planning to Play",
    choice(status = "Completed", "✅ Completed Games",
    choice(status = "On Hold", "⏸️ On Hold",
    choice(status = "Dropped", "❌ Dropped Games", "📂 Not Started"))))) as "Status",
  length(rows.file) as "Count"
FROM "${this.settings.gamesFolder}"
WHERE contains(file.name, "Game Overview")
GROUP BY status
SORT Status
\`\`\`

## 🎯 Currently Playing

\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, game_name) as "Game",
  current_playthrough as "Playthrough",
  choice(last_session, last_session, "Never") as "Last Session",
FROM "${this.settings.gamesFolder}"
WHERE contains(file.name, "Game Overview") AND status = "Playing"
SORT last_session DESC
\`\`\`

## 📋 Up Next (Planning)

\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, game_name) as "Game",
  store_platform as "Platform",
  choice(total_playthroughs, total_playthroughs, 0) as "Playthroughs"
FROM "${this.settings.gamesFolder}"
WHERE contains(file.name, "Game Overview") AND status = "Planning"
SORT game_name
\`\`\`

## ⏸️ On Hold

\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, game_name) as "Game",
  current_playthrough as "Playthrough",
  choice(last_session, last_session, "Never") as "Last Session",
FROM "${this.settings.gamesFolder}"
WHERE contains(file.name, "Game Overview") AND status = "On Hold"
SORT last_session DESC
\`\`\`

## ✅ Recently Completed

\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, game_name) as "Game",
  choice(completion_date, completion_date, "Unknown") as "Completed",
  choice(rating, "⭐".repeat(number(rating)), "Not Rated") as "Rating"
FROM "${this.settings.gamesFolder}"
WHERE contains(file.name, "Game Overview") AND status = "Completed"
SORT completion_date DESC
LIMIT 10
\`\`\`

## 📊 Platform Breakdown

\`\`\`dataview
TABLE WITHOUT ID
  store_platform as "Platform",
  length(rows.file) as "Games"
FROM "${this.settings.gamesFolder}"
WHERE contains(file.name, "Game Overview") AND store_platform
GROUP BY store_platform
SORT store_platform
\`\`\`

## 🕐 Recent Activity

\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, "Session " + string(session_number)) as "Session",
  game_name as "Game",
  session_date as "Date",
FROM "${this.settings.gamesFolder}"
WHERE contains(file.path, "/Sessions/") AND !contains(file.name, "_current_session_")
SORT session_date DESC
LIMIT 15
\`\`\`

## 📈 Gaming Stats

### All Time
- **Total Games**: \`= length(filter(file.lists.file, (f) => contains(f.path, "${this.settings.gamesFolder}") AND contains(f.name, "Game Overview")))\`
- **Completed Games**: \`= length(filter(file.lists.file, (f) => contains(f.path, "${this.settings.gamesFolder}") AND contains(f.name, "Game Overview") AND file.frontmatter.status = "Completed"))\`
- **Total Sessions**: \`= length(filter(file.lists.file, (f) => contains(f.path, "${this.settings.gamesFolder}/") AND contains(f.path, "/Sessions/") AND !contains(f.name, "_current_session_")))\`

### This Month
\`\`\`dataview
TABLE WITHOUT ID
  "Sessions Played" as "Metric",
  length(rows.file) as "Count"
FROM "${this.settings.gamesFolder}"
WHERE contains(file.path, "/Sessions/") 
  AND !contains(file.name, "_current_session_")
  AND date(session_date) >= date(now) - dur(30 days)
\`\`\`

---

## 🔧 Quick Actions

\`BUTTON[openLibrary]\` \`BUTTON[addNewGame]\` \`BUTTON[refreshLibrary]\`

---

*This overview is automatically generated. To update it, run the "Refresh Library Overview" command.*

> [!tip] Pro Tip
> This overview uses Dataview queries to automatically pull information from your game files. If numbers look wrong, make sure your game files have proper frontmatter with status, dates, and other metadata.

> [!note] Coming in v0.9
> This overview will be migrated to use Obsidian Bases for better performance and more dynamic features.
`;
}

    // Helper methods for auto-creation logic

    private hasAnyGames(): boolean {
        const gamesFolder = this.app.vault.getAbstractFileByPath(this.settings.gamesFolder);
        if (!(gamesFolder instanceof TFolder)) return false;
        
        return gamesFolder.children.some(child => 
            child instanceof TFolder && 
            child.children.some(file => 
                file instanceof TFile && file.name.endsWith('Game Overview.md')
            )
        );
    }

    async ensureLibraryOverviewExists() {
        const overviewPath = `${this.settings.gamesFolder}/📊 Library Overview.md`;
        const existingFile = this.app.vault.getAbstractFileByPath(overviewPath);
        
        if (!existingFile && this.hasAnyGames()) {
            await this.createLibraryOverview(false); // Silent creation
        }
    }

    // Device Management Methods
    isStoreCompatible(store: string, platform: string): boolean {
        const compatibility: Record<string, string[]> = {
            'Steam': ['Windows', 'Mac', 'Linux', 'SteamOS'],
            'Epic Games Store': ['Windows', 'Mac'],
            'GOG': ['Windows', 'Mac', 'Linux'],
            'Xbox App': ['Windows'],
            'Origin/EA App': ['Windows'],
            'Ubisoft Connect': ['Windows'],
            'Battle.net': ['Windows', 'Mac'],
            'Itch.io': ['Windows', 'Mac', 'Linux'],
            'Humble Store': ['Windows', 'Mac', 'Linux', 'SteamOS'],
            'PlayStation Store': ['PlayStation'],
            'Xbox Store': ['Xbox'],
            'Nintendo eShop': ['Nintendo'],
            'App Store': ['iOS'],
            'Google Play Store': ['Android'],
            // Add retro/emulation support
            'ROM Files': ['Emulation', 'FPGA', 'Atari', 'Sega', 'SNK', 'NEC', 'Bandai', 'Nintendo', 'PlayStation', 'Xbox', 'Other'],
            'Cartridge/Physical': ['Nintendo', 'Sega', 'Atari', 'SNK', 'NEC', 'Bandai', 'PlayStation', 'Xbox', 'Other'],
            'Digital Archive': ['Emulation', 'FPGA', 'Other'],
            'No Store Required': ['Emulation', 'FPGA', 'Atari', 'Sega', 'Nintendo', 'PlayStation', 'Xbox', 'SNK', 'NEC', 'Bandai', 'Other']
        };
        
        return compatibility[store]?.includes(platform) || false;
    }

    getActiveDevices(): UserDevice[] {
        return this.settings.userDevices.filter(device => 
            device.platforms.length > 0 && (
                Object.values(device.platformStores).some(stores => stores.length > 0) ||
                Object.values(device.platformSubscriptions).some(subs => subs.length > 0)
            )
        );
    }

    getAllDevices(): UserDevice[] {
        return this.settings.userDevices;
    }

    hasPlatform(platform: string): boolean {
        if (platform === 'PC') {
            return this.settings.userDevices.some(d => 
                d.platforms.some(p => ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(p))
            );
        }
        
        return this.settings.userDevices.some(d => d.platforms.includes(platform));
    }

    async createDefaultDeviceForPlatform(platform: string): Promise<UserDevice | null> {
        const actualPlatform = platform === 'PC' ? 'Windows' : platform;
        
        const existingDevice = this.settings.userDevices.find(d => {
            if (platform === 'PC') {
                return d.platforms.some(p => ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(p));
            }
            return d.platforms.includes(actualPlatform);
        });
        
        if (existingDevice) return existingDevice;

        const deviceNames: Record<string, string> = {
            'Windows': 'Gaming PC',
            'PlayStation': 'PlayStation 5',
            'Xbox': 'Xbox Series X|S',
            'Nintendo': 'Nintendo Switch'
        };
        
        const deviceTypes: Record<string, DeviceType> = {
            'Windows': 'computer',
            'PlayStation': 'console',
            'Xbox': 'console',
            'Nintendo': 'console'
        };
        
        const deviceName = deviceNames[actualPlatform];
        const deviceType = deviceTypes[actualPlatform];
        
        if (!deviceName || !deviceType) return null;
        
        const newDevice = await this.addDevice(deviceName, deviceType, [actualPlatform]);
        newDevice.isAutoGenerated = true;
        await this.saveSettings();
        
        return newDevice;
    }

    async removeDevicesForPlatform(platform: string): Promise<boolean> {
        let devicesForPlatform;
        
        if (platform === 'PC') {
            devicesForPlatform = this.settings.userDevices.filter(d => 
                d.platforms.some(p => ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(p))
            );
        } else {
            devicesForPlatform = this.settings.userDevices.filter(d => 
                d.platforms.includes(platform)
            );
        }
        
        if (devicesForPlatform.length === 0) return false;
        
        const deviceNames = devicesForPlatform.map(d => d.name).join(', ');
        const confirmed = confirm(`Remove all ${platform} devices (${deviceNames})? This cannot be undone.`);
        
        if (!confirmed) return false;
        
        if (platform === 'PC') {
            this.settings.userDevices = this.settings.userDevices.filter(d => 
                !d.platforms.some(p => ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(p))
            );
        } else {
            this.settings.userDevices = this.settings.userDevices.filter(d => 
                !d.platforms.includes(platform)
            );
        }
        
        await this.saveSettings();
        return true;
    }

    async addDevice(deviceName: string, deviceType: DeviceType, initialPlatforms: string[]): Promise<UserDevice> {
        // Ensure initialPlatforms is an array
        const platforms = Array.isArray(initialPlatforms) ? initialPlatforms : [initialPlatforms];
        
        const platformStores: Record<string, string[]> = {};
        const platformSubscriptions: Record<string, string[]> = {};
        
        // Set up stores and subscriptions for each platform
        platforms.forEach(platform => {
            const availableSubscriptions = this.getSubscriptionsForPlatform(platform);
            
            if (['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(platform)) {
                // For PC platforms, only use stores that are already enabled for this specific platform
                platformStores[platform] = this.getEnabledPCStoresForNewDevice(platform);
            } else {
                // For non-PC platforms, use all compatible stores
                platformStores[platform] = this.getCompatibleStoresForPlatform(platform);
            }
            
            platformSubscriptions[platform] = availableSubscriptions.filter(sub => 
                this.settings.enabledSubscriptions[sub] === true
            );
        });

        const newDevice: UserDevice = {
            id: `device-${Date.now()}`,
            name: deviceName,
            type: deviceType,
            platforms: platforms,
            platformStores: platformStores,
            platformSubscriptions: platformSubscriptions,
            isDefault: !this.settings.userDevices.some(d => 
                d.platforms.some(p => platforms.includes(p)) && d.isDefault
            ),
            isAutoGenerated: false
        };

        this.settings.userDevices.push(newDevice);
        await this.saveSettings();
        
        return newDevice;
    }

    async removeDevice(deviceId: string): Promise<boolean> {
        const deviceIndex = this.settings.userDevices.findIndex(d => d.id === deviceId);
        
        if (deviceIndex === -1) {
            return false;
        }

        const device = this.settings.userDevices[deviceIndex];
        
        if (this.settings.userDevices.length === 1) {
            new Notice('⚠️ Cannot remove the last device. Add another device first.');
            return false;
        }

        if (device.isDefault) {
            const sameplatformDevices = this.settings.userDevices.filter(d => 
                d.platforms.some(p => device.platforms.includes(p)) && d.id !== deviceId
            );
            
            if (sameplatformDevices.length > 0) {
                sameplatformDevices[0].isDefault = true;
            }
        }

        this.settings.userDevices.splice(deviceIndex, 1);
        await this.saveSettings();
        
        new Notice(`🗑️ Removed device: ${device.name}`);
        return true;
    }

    async updateDeviceSubscriptions() {
        let hasChanges = false;
        
        this.settings.userDevices = this.settings.userDevices.map(device => {
            const newPlatformSubscriptions: Record<string, string[]> = {};
            
            // Update subscriptions for each platform
            device.platforms.forEach(platform => {
                const availableSubscriptions = this.getSubscriptionsForPlatform(platform);
                newPlatformSubscriptions[platform] = availableSubscriptions.filter(sub => 
                    this.settings.enabledSubscriptions[sub] === true
                );
            });
            
            // Check if anything changed
            if (JSON.stringify(device.platformSubscriptions) !== JSON.stringify(newPlatformSubscriptions)) {
                hasChanges = true;
            }
            
            return {
                ...device,
                platformSubscriptions: newPlatformSubscriptions
            };
        });
        
        if (hasChanges) {
            await this.saveSettings();
        }
    }

    getCompatibleStoresForDevice(device: UserDevice): string[] {
        const allPossibleStores = [
            'Steam', 'Epic Games Store', 'GOG', 'Xbox App', 
            'Origin/EA App', 'Ubisoft Connect', 'Battle.net', 'Itch.io',
            'Humble Store', 'PlayStation Store', 'Xbox Store', 'Nintendo eShop',
            'App Store', 'Google Play Store', 'ROM Files', 'Cartridge/Physical',
            'Digital Archive', 'No Store Required'
        ];
        
        // Get all compatible stores across all platforms for this device
        const compatibleStores = new Set<string>();
        device.platforms.forEach(platform => {
            allPossibleStores.forEach(store => {
                if (this.isStoreCompatible(store, platform)) {
                    compatibleStores.add(store);
                }
            });
        });
        
        return Array.from(compatibleStores);
    }

    getCompatibleStoresForPlatform(platform: string): string[] {
        // Define platform-specific stores
        const platformStoreMap: Record<string, string[]> = {
            // PC Platforms
            'Windows': ['Steam', 'Epic Games Store', 'GOG', 'Xbox App', 'Origin/EA App', 'Ubisoft Connect', 'Battle.net', 'Itch.io', 'Humble Store'],
            'Mac': ['Steam', 'Epic Games Store', 'GOG', 'App Store'],
            'Linux': ['Steam', 'GOG', 'Itch.io'],
            'SteamOS': ['Steam'],
            
            // Console Platforms
            'PlayStation': ['PlayStation Store'],
            'Xbox': ['Xbox Store'],
            'Nintendo': ['Nintendo eShop'],
            
            // Mobile Platforms
            'iOS': ['App Store'],
            'Android': ['Google Play Store'],
            
            // Retro/Emulation Platforms (only these should get retro stores)
            'Retro': ['ROM Files', 'Cartridge/Physical'],
            'Emulation': ['ROM Files'],
            'Other': ['No Store']
        };
        
        return platformStoreMap[platform] || [];
    }

    private getEnabledPCStoresForNewDevice(targetPlatform: string): string[] {
        // Get stores that are currently enabled on existing devices for this specific platform
        const devicesWithPlatform = this.settings.userDevices.filter(d => 
            d.platforms.includes(targetPlatform)
        );
        
        if (devicesWithPlatform.length === 0) {
            // No existing devices for this platform - check if there are any PC devices at all
            const anyPCDevices = this.settings.userDevices.filter(d => 
                d.platforms.some(p => ['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(p))
            );
            
            if (anyPCDevices.length === 0) {
                // No PC devices at all - use minimal default
                return ['Steam'];
            } else {
                // There are PC devices, but none for this specific platform
                // Get the intersection of enabled stores that are compatible with this platform
                const allEnabledStores = new Set<string>();
                anyPCDevices.forEach(device => {
                    device.platforms.forEach(platform => {
                        if (['PC', 'Windows', 'Mac', 'Linux', 'SteamOS'].includes(platform)) {
                            if (device.platformStores[platform]) {
                                device.platformStores[platform].forEach(store => allEnabledStores.add(store));
                            }
                        }
                    });
                });
                
                // Filter to only stores compatible with the target platform
                const compatibleStores = this.getCompatibleStoresForPlatform(targetPlatform);
                return Array.from(allEnabledStores).filter(store => compatibleStores.includes(store));
            }
        }
        
        // Get stores that are enabled on existing devices for this platform
        const enabledStores = new Set<string>();
        devicesWithPlatform.forEach(device => {
            if (device.platformStores[targetPlatform]) {
                device.platformStores[targetPlatform].forEach(store => enabledStores.add(store));
            }
        });
        
        return Array.from(enabledStores);
    }


    getSubscriptionsForPlatform(platform: string): string[] {
        const platformSubscriptionMap: Record<string, string[]> = {
            'Windows': ['PC Game Pass', 'EA Play', 'Ubisoft+'],
            'Mac': ['Apple Arcade'],
            'Linux': [],
            'SteamOS': [],
            'PlayStation': ['PlayStation Plus', 'EA Play', 'Ubisoft+'],
            'Xbox': ['Xbox Game Pass', 'EA Play', 'Ubisoft+'],
            'Nintendo': ['Nintendo Switch Online'],
            'iOS': ['Apple Arcade'],
            'Android': ['Google Play Pass'],
            'Emulation': [],
            'FPGA': [],
            'Atari': [],
            'Sega': [],
            'SNK': [],
            'NEC': [],
            'Bandai': [],
            'Other': []
        };
        
        return platformSubscriptionMap[platform] || [];
    }

    // Auto-save system
    private autoSaveInterval: NodeJS.Timeout | null = null;
    private currentPlaythroughFile: TFile | null = null;

    private startAutoSave(playthroughFile: TFile) {
        // Stop any existing auto-save
        this.stopAutoSave();
        
        this.currentPlaythroughFile = playthroughFile;
        
        // Auto-save every 30 seconds
        this.autoSaveInterval = setInterval(async () => {
            await this.performAutoSave();
        }, 30000);
        
        console.log('Auto-save started for:', playthroughFile.path);
    }

    private stopAutoSave() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
        this.currentPlaythroughFile = null;
        console.log('Auto-save stopped');
    }

    private async performAutoSave() {
        if (!this.currentPlaythroughFile) return;
        
        try {
            const cache = this.app.metadataCache.getFileCache(this.currentPlaythroughFile);
            const frontmatter = cache?.frontmatter;
            
            if (!frontmatter || !frontmatter.session_active) {
                this.stopAutoSave();
                return;
            }

            const currentNotes = frontmatter.current_session_notes || '';
            
            if (currentNotes.trim()) {
                // Create auto-save snapshot
                await this.createAutoSaveSnapshot(this.currentPlaythroughFile, frontmatter, currentNotes);
                
                // Update last auto-save timestamp
                await this.app.fileManager.processFrontMatter(this.currentPlaythroughFile, (fm) => {
                    fm.last_autosave = new Date().toISOString();
                });
            }
            
        } catch (error) {
            console.error('Auto-save error:', error);
        }
    }

    private async createAutoSaveSnapshot(playthroughFile: TFile, frontmatter: Record<string, unknown>, notes: string) {
        const snapshotPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions/_current_session_${frontmatter.playthrough_id}.md`;
        
        const snapshotContent = `---
game_name: "${frontmatter.game_name}"
playthrough_name: "${frontmatter.playthrough_name}"
playthrough_id: "${frontmatter.playthrough_id}"
session_date: "${new Date().toISOString().split('T')[0]}"
auto_save_timestamp: "${new Date().toISOString()}"
status: "in_progress"
tags:
  - session-snapshot
---

# Current Session - ${frontmatter.game_name} | ${frontmatter.playthrough_name}

**Auto-saved**: ${new Date().toLocaleString()}

## Session Notes

${notes}

## Current Status
- **Level**: ${frontmatter.current_level || 'Unknown'}
- **Location**: ${frontmatter.current_location || 'Unknown'}

---
*This is an auto-save snapshot. It will be converted to a proper session log when you end your session.*`;

        try {
            const existingFile = this.app.vault.getAbstractFileByPath(snapshotPath);
            
            if (existingFile instanceof TFile) {
                await this.app.vault.modify(existingFile, snapshotContent);
            } else {
                await this.app.vault.create(snapshotPath, snapshotContent);
            }
            
        } catch (error) {
            console.error('Error creating auto-save snapshot:', error);
        }
    }

    private async createSessionLog(playthroughFile: TFile, frontmatter: Record<string, unknown>) {
        // Calculate session info
        const sessionNumber = (typeof frontmatter.total_sessions === 'number' ? frontmatter.total_sessions : 0) + 1;
        const sessionStartTime = typeof frontmatter.session_start_time === 'string' ? frontmatter.session_start_time : new Date().toISOString();
        const sessionEndTime = new Date().toISOString();
        const sessionDate = new Date().toISOString().split('T')[0];
        
        // Calculate duration
        const startTime = new Date(sessionStartTime);
        const endTime = new Date(sessionEndTime);
        const durationMinutes = Math.round((endTime.getTime() - startTime.getTime()) / (1000 * 60));
        const durationHours = Math.floor(durationMinutes / 60);
        const remainingMinutes = durationMinutes % 60;
        const durationText = durationHours > 0 
            ? `${durationHours}h ${remainingMinutes}m` 
            : `${remainingMinutes}m`;

        // Get session notes
        let sessionNotes = typeof frontmatter.current_session_notes === 'string' ? frontmatter.current_session_notes : '';
        
        // Check for auto-save snapshot with more recent notes
        const snapshotPath = `${this.settings.gamesFolder}/${frontmatter.game_name}/Sessions/_current_session_${frontmatter.playthrough_id}.md`;
        const snapshotFile = this.app.vault.getAbstractFileByPath(snapshotPath);
        
        if (snapshotFile instanceof TFile) {
            const snapshotContent = await this.app.vault.read(snapshotFile);
            const notesMatch = snapshotContent.match(/## Session Notes\n\n([\s\S]*?)\n\n## Current Status/);
            if (notesMatch && notesMatch[1].trim()) {
                sessionNotes = notesMatch[1].trim();
            }
            // Clean up snapshot file
            await this.app.vault.delete(snapshotFile);
        }

        // Sanitize game name for file path
        const safeGameName = this.sanitizeForFileSystem(frontmatter.game_name as string);
        
        // Create session log content
        const sessionLogContent = `---
game_name: "${frontmatter.game_name}"
playthrough_name: "${frontmatter.playthrough_name}"
playthrough_id: "${frontmatter.playthrough_id}"
session_number: ${sessionNumber}
session_date: "${sessionDate}"
start_time: "${sessionStartTime}"
end_time: "${sessionEndTime}"
duration: "${durationText}"
status: "completed"
tags:
  - session-log
  - ${typeof frontmatter.game_name === 'string' ? frontmatter.game_name.toLowerCase().replace(/[^a-z0-9]/g, '-') : 'unknown-game'}
---

# ${frontmatter.game_name} - ${frontmatter.playthrough_name} - Session ${sessionNumber}

**Date**: ${sessionDate}  

## What Happened This Session

${sessionNotes || 'No notes recorded for this session.'}

## Notes for Next Session

${frontmatter.notes_for_next_session || 'No notes for next session.'}

---

*Session automatically logged from Playthrough Dashboard*`;

        // Use sanitized game name for folder path but keep original for filename display
        const sessionLogPath = `${this.settings.gamesFolder}/${safeGameName}/Sessions/Session ${sessionNumber} - ${sessionDate} - ${frontmatter.playthrough_id}.md`;
        await this.app.vault.create(sessionLogPath, sessionLogContent);

        // Update playthrough dashboard
        await this.app.fileManager.processFrontMatter(playthroughFile, (fm) => {
            fm.total_sessions = sessionNumber;
            fm.last_session = sessionDate;
            fm.session_active = false;
            fm.current_session_notes = ""; // Clear for next session
            fm.notes_from_last_session = fm.notes_for_next_session || "";
            fm.notes_for_next_session = ""; // Clear for new input
            delete fm.session_start_time;
            delete fm.last_autosave;
        });
    }

    onunload() {
        // Cleanup when plugin is disabled
    }
}

     class ConfirmModal extends Modal {
        private title: string;
        private message: string;
        private resolve: (value: boolean) => void = () => {};

        constructor(app: App, title: string, message: string) {
            super(app);
            this.title = title;
            this.message = message;
        }

        waitForUserChoice(): Promise<boolean> {
            return new Promise((resolve) => {
                this.resolve = resolve;
                this.open();
            });
        }

        onOpen() {
            const { contentEl } = this;
            contentEl.empty();

            contentEl.createEl('h2', { text: this.title });
            contentEl.createEl('p', { text: this.message });

            const buttonContainer = contentEl.createDiv();
            buttonContainer.style.cssText = `
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            `;

            const cancelButton = buttonContainer.createEl('button', {
                text: 'Cancel',
                cls: 'mod-cancel'
            });
            cancelButton.onclick = () => {
                this.resolve(false);
                this.close();
            };

            const confirmButton = buttonContainer.createEl('button', {
                text: 'Confirm',
                cls: 'mod-cta'
            });
            confirmButton.onclick = () => {
                this.resolve(true);
                this.close();
            };
        }

        onClose() {
            const { contentEl } = this;
            contentEl.empty();
        }
    }

    class FinalThoughtsModal extends Modal {
        private onSubmit: (thoughts: string) => void;
        private finalThoughts = '';

        constructor(app: App, onSubmit: (thoughts: string) => void) {
            super(app);
            this.onSubmit = onSubmit;
        }

        onOpen() {
            const { contentEl } = this;
            contentEl.empty();

            contentEl.createEl('h2', { text: 'Final Thoughts' });
            contentEl.createEl('p', { 
                text: 'Any final thoughts about this playthrough? (optional)',
                cls: 'setting-item-description'
            });

        const textAreaContainer = contentEl.createDiv();
            textAreaContainer.style.cssText = `
                margin: 15px 0;
            `;

        const textArea = textAreaContainer.createEl('textarea');
            textArea.placeholder = 'What did you think of this playthrough? Any highlights or memorable moments?';
            textArea.value = this.finalThoughts;
            textArea.style.cssText = `
                width: 100%;
                min-height: 120px;
                padding: 10px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 6px;
                background: var(--background-primary);
                color: var(--text-normal);
                font-family: var(--font-interface);
                font-size: 14px;
                resize: vertical;
            `;

            textArea.addEventListener('input', (e) => {
                this.finalThoughts = (e.target as HTMLTextAreaElement).value;
            });

        const buttonContainer = contentEl.createDiv();
            buttonContainer.style.cssText = `
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            `;

        const skipButton = buttonContainer.createEl('button', {
                text: 'Skip',
                cls: 'mod-cancel'
            });
            skipButton.onclick = () => {
                this.onSubmit('');
                this.close();
            };

        const saveButton = buttonContainer.createEl('button', {
                text: 'Save Thoughts',
                cls: 'mod-cta'
            });
            saveButton.onclick = () => {
                this.onSubmit(this.finalThoughts);
                this.close();
            };

        }

        onClose() {
            const { contentEl } = this;
            contentEl.empty();
        }
    }  

// Add this class to main.ts after the other modal classes

interface ShareNotesData {
    gameName: string;
    playthroughName: string;
    currentNotes: string;
    notesForNext: string;
    sessionActive: boolean;
    totalSessions: number;
    lastSession: string;
    isFromLastSession?: boolean;
}

class ShareNotesModal extends Modal {
    private data: ShareNotesData;

    constructor(app: App, data: ShareNotesData) {
        super(app);
        this.data = data;
    }

    onOpen() {
        const { contentEl, modalEl } = this;
        
        modalEl.style.cssText = `
            max-width: 600px;
            width: 90vw;
            min-height: 300px;
        `;
        
        contentEl.empty();
        contentEl.createEl('h2', { text: 'Share Session Notes' });
        
        // Show indicator if sharing from last session
        if (this.data.isFromLastSession) {
            const indicator = contentEl.createDiv();
            indicator.style.cssText = `
                background: var(--background-secondary);
                border: 1px solid var(--background-modifier-border);
                border-radius: 6px;
                padding: 10px;
                margin: 10px 0;
                color: var(--text-muted);
                font-style: italic;
            `;
            indicator.textContent = '📋 Sharing notes from your last completed session';
        }
        
        // Check if there are notes to share
        if (!this.data.currentNotes.trim() && !this.data.notesForNext.trim()) {
            contentEl.createEl('p', { 
                text: '📝 No session notes to share. Add some notes to your current or next session first!',
                cls: 'setting-item-description'
            });
            
            const closeButton = contentEl.createEl('button', { text: 'Close' });
            closeButton.style.cssText = `margin-top: 20px;`;
            closeButton.onclick = () => this.close();
            return;
        }
        
        // Preview section
        const previewSection = contentEl.createDiv('share-preview');
        previewSection.createEl('h3', { text: 'Preview:' });
        
        const previewBox = previewSection.createDiv('preview-box');
        previewBox.style.cssText = `
            background: var(--background-secondary);
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            font-family: var(--font-monospace);
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        `;
        
        // Format options
        const formatSection = contentEl.createDiv('format-options');
        formatSection.createEl('h3', { text: 'Choose Format:' });
        
        const buttonContainer = formatSection.createDiv('format-buttons');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        `;
        
        // Plain text button
        const plainButton = buttonContainer.createEl('button', { text: '📄 Plain Text' });
        plainButton.style.cssText = `
            padding: 12px 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        `;
        plainButton.onclick = () => {
            const formatted = this.formatPlainText();
            this.updatePreview(previewBox, formatted);
            this.copyToClipboard(formatted, 'Plain text');
        };
        
        // Discord/Markdown format button
        const discordButton = buttonContainer.createEl('button', { text: '💬 Discord/Markdown' });
        discordButton.style.cssText = `
            padding: 12px 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        `;
        discordButton.onclick = () => {
            const formatted = this.formatMarkdown();
            this.updatePreview(previewBox, formatted);
            this.copyToClipboard(formatted, 'Discord/Markdown format');
        };
        
        // Initialize with plain text preview
        this.updatePreview(previewBox, this.formatPlainText());
        
        // Close button
        const closeContainer = contentEl.createDiv();
        closeContainer.style.cssText = `
            display: flex;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--background-modifier-border);
        `;
        
        const closeButton = closeContainer.createEl('button', { text: 'Close' });
        closeButton.onclick = () => this.close();
    }
    
    private updatePreview(previewElement: HTMLElement, content: string) {
        previewElement.textContent = content;
    }
    
    private stripMarkdown(text: string): string {
        return text
            // Remove headers
            .replace(/^#+\s*/gm, '')
            // Remove bold/italic
            .replace(/\*\*(.+?)\*\*/g, '$1')
            .replace(/\*(.+?)\*/g, '$1')
            .replace(/__(.+?)__/g, '$1')
            .replace(/_(.+?)_/g, '$1')
            // Remove links but keep text
            .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
            // Remove inline code
            .replace(/`([^`]+)`/g, '$1')
            // Remove strikethrough
            .replace(/~~(.+?)~~/g, '$1')
            // Clean up extra whitespace
            .replace(/\n\s*\n/g, '\n\n')
            .trim();
    }
    
    private formatPlainText(): string {
        const { gameName, playthroughName, currentNotes, notesForNext } = this.data;
        
        let formatted = `🎮 ${gameName} | ${playthroughName}\n\n`;
        
        if (currentNotes.trim()) {
            const cleanNotes = this.stripMarkdown(currentNotes);
            formatted += `What I did this session:\n${cleanNotes}\n\n`;
        }
        
        if (notesForNext.trim()) {
            const cleanPlans = this.stripMarkdown(notesForNext);
            formatted += `Plans for next time:\n${cleanPlans}\n\n`;
        }
        
        formatted += `---\nShared from Obsidian Game Log`;
        
        return formatted;
    }
    
    private formatMarkdown(): string {
        const { gameName, playthroughName, currentNotes, notesForNext } = this.data;
        
        let formatted = `🎮 **${gameName}** | *${playthroughName}*\n\n`;
        
        if (currentNotes.trim()) {
            formatted += `**What I did this session:**\n${currentNotes.trim()}\n\n`;
        }
        
        if (notesForNext.trim()) {
            formatted += `**Plans for next time:**\n${notesForNext.trim()}\n\n`;
        }
        
        formatted += `*Shared from Obsidian Game Log*`;
        
        return formatted;
    }
    
    private async copyToClipboard(text: string, formatName: string) {
        try {
            await navigator.clipboard.writeText(text);
            new Notice(`📋 ${formatName} copied to clipboard!`);
        } catch (error) {
            console.error('Failed to copy to clipboard:', error);
            new Notice('❌ Failed to copy to clipboard');
        }
    }
    
    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}